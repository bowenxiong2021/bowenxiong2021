<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/14/%E8%A7%A3%E9%87%8A%20SQL%20%E7%9A%84%20left%20join%20%E5%92%8C%20right%20join/"/>
    <url>/2021/07/14/%E8%A7%A3%E9%87%8A%20SQL%20%E7%9A%84%20left%20join%20%E5%92%8C%20right%20join/</url>
    
    <content type="html"><![CDATA[<h4 id="题目：解释-SQL-的-left-join-和-right-join"><a href="#题目：解释-SQL-的-left-join-和-right-join" class="headerlink" title="题目：解释 SQL 的 left join 和 right join"></a><strong>题目</strong>：解释 SQL 的 left join 和 right join</h4><h4 id="出题人：阿里巴巴新零售技术质量部"><a href="#出题人：阿里巴巴新零售技术质量部" class="headerlink" title="出题人：阿里巴巴新零售技术质量部"></a>出题人：阿里巴巴新零售技术质量部</h4><h4 id="参考答案："><a href="#参考答案：" class="headerlink" title="参考答案："></a><strong>参考答案</strong>：</h4><p>left join 和 right join 都是两个表进行 merge 的操作，left join 是将右边的表 merge 到左边，right join 是将左边的表 merge 到右边，通常我们会指定按照哪几列进行 merge</p><p>举个例子：</p><p><strong>left table</strong></p><table><thead><tr><th>姓名</th><th>学号</th></tr></thead><tbody><tr><td>小红</td><td>SZ1716029</td></tr><tr><td>小明</td><td>SZ1716030</td></tr><tr><td>小王</td><td>SZ1716031</td></tr></tbody></table><p><strong>right table</strong></p><table><thead><tr><th>学号</th><th>排名</th></tr></thead><tbody><tr><td>SZ1716029</td><td>1</td></tr><tr><td>SZ1716030</td><td>2</td></tr></tbody></table><p><strong>left table</strong> left join <strong>right table</strong> on 学号</p><table><thead><tr><th>学号</th><th>姓名</th><th>排名</th></tr></thead><tbody><tr><td>SZ1716029</td><td>小红</td><td>1</td></tr><tr><td>SZ1716030</td><td>小明</td><td>2</td></tr><tr><td>SZ1716031</td><td>小王</td><td>NULL</td></tr></tbody></table><p><strong>left table</strong> right join <strong>right table</strong> on 学号</p><table><thead><tr><th>学号</th><th>姓名</th><th>排名</th></tr></thead><tbody><tr><td>SZ1716029</td><td>小红</td><td>1</td></tr><tr><td>SZ1716030</td><td>小明</td><td>2</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/14/%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E8%A7%86%E5%9B%BE%E5%8F%AF%E4%BB%A5%E6%9B%B4%E6%94%B9%E4%B9%88%EF%BC%9F/"/>
    <url>/2021/07/14/%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E8%A7%86%E5%9B%BE%E5%8F%AF%E4%BB%A5%E6%9B%B4%E6%94%B9%E4%B9%88%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="题目：视图的作用，视图可以更改么？"><a href="#题目：视图的作用，视图可以更改么？" class="headerlink" title="题目：视图的作用，视图可以更改么？"></a><strong>题目</strong>：视图的作用，视图可以更改么？</h4><h4 id="参考答案："><a href="#参考答案：" class="headerlink" title="参考答案："></a><strong>参考答案</strong>：</h4><p>视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；不包含任何列或数据。使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。</p><p>视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。</p><p>创建视图：create view XXX as XXXXXXXXXXXXXX;</p><p>对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新；但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/14/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E7%A7%8D%E7%B1%BB/"/>
    <url>/2021/07/14/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E7%A7%8D%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h4 id="题目：索引的工作原理及其种类"><a href="#题目：索引的工作原理及其种类" class="headerlink" title="题目：索引的工作原理及其种类"></a><strong>题目</strong>：索引的工作原理及其种类</h4><h4 id="参考答案："><a href="#参考答案：" class="headerlink" title="参考答案："></a><strong>参考答案</strong>：</h4><p><strong>数据库索引</strong>，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><p>为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p><p><img src=http://www.2cto.com/uploadfile/Collfiles/20150416/2015041610033731.png> </img></p><p>图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。</p><p>创建索引可以大大提高系统的性能。</p><p>第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p><p>第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p><p>第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p><p>第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p><p>第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p>也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。</p><p>第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><p>第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p><p>第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p><p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说，应该在这些列上创建索引：在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p><p>同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点：</p><p>第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p><p>第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p><p>第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</p><p>第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p><p>根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。</p><p>唯一索引</p><p>唯一索引是不允许其中任何两行具有相同索引值的索引。</p><p>当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。 主键索引 数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 聚集索引 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。</p><p>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p><p>局部性原理与磁盘预读<br>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</p><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><p>B-/+Tree索引的性能分析<br>到这里终于可以分析B-/+Tree索引的性能了。</p><p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p><p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/14/%E6%B5%85%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B7%B1%E5%A4%8D%E5%88%B6%EF%BC%9F%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%A4%8D%E5%88%B6%EF%BC%9F/"/>
    <url>/2021/07/14/%E6%B5%85%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B7%B1%E5%A4%8D%E5%88%B6%EF%BC%9F%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%A4%8D%E5%88%B6%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="题目：浅复制和深复制？怎样实现深复制？"><a href="#题目：浅复制和深复制？怎样实现深复制？" class="headerlink" title="题目：浅复制和深复制？怎样实现深复制？"></a><strong>题目</strong>：浅复制和深复制？怎样实现深复制？</h4><h4 id="出题人：阿里巴巴新零售技术质量部"><a href="#出题人：阿里巴巴新零售技术质量部" class="headerlink" title="出题人：阿里巴巴新零售技术质量部"></a><strong>出题人</strong>：阿里巴巴新零售技术质量部</h4><h4 id="参考答案："><a href="#参考答案：" class="headerlink" title="参考答案："></a><strong>参考答案</strong>：</h4><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码;"></a><strong>参考代码</strong>;</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> isObject = <span class="hljs-function">(<span class="hljs-params">item</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(item) === <span class="hljs-string">&#x27;[object Object]&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">const</span> isArray = <span class="hljs-function">(<span class="hljs-params">item</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(item) === <span class="hljs-string">&#x27;[object Array]&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> deepClone=<span class="hljs-function">(<span class="hljs-params">obj</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">const</span> cloneObj=isArray(obj)?[]:isObject(obj)?&#123;&#125;:<span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj)&#123;<br>        <span class="hljs-keyword">if</span>(isObject(obj[key])||isArray(obj[key]))&#123;<br>          <span class="hljs-built_in">Object</span>.assign(cloneObj,&#123;<br>           [key]: deepClone(<span class="hljs-built_in">Reflect</span>.get(obj,key))<br>          &#125;);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>          cloneObj[key] = obj[key];<br>        &#125;  <br>    &#125;<br>    <span class="hljs-keyword">return</span> cloneObj;<br>&#125;<br></code></pre></td></tr></table></figure><p>PS:可以处理这样的格式,仅处理了对象类型和数组类型</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dts">const obj111 =&#123;<br><span class="hljs-symbol">  a:</span><span class="hljs-number">1</span>,<br><span class="hljs-symbol">  b:</span>&#123;<br><span class="hljs-symbol">    c:</span><span class="hljs-number">2</span>,<br><span class="hljs-symbol">    d:</span>&#123;<br><span class="hljs-symbol">      e:</span><span class="hljs-number">3</span><br>    &#125;,<br><span class="hljs-symbol">    f:</span>[<span class="hljs-number">1</span>,&#123;a:<span class="hljs-number">1</span>,b:<span class="hljs-number">2</span>&#125;,<span class="hljs-number">3</span>]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的"><a href="#请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的" class="headerlink" title="请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的"></a>请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>基本概念：</p><p>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</p><p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p><p>区别：</p><p>1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p><p>2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p><p>3.进程是资源分配的最小单位，线程是CPU调度的最小单位；</p><p>4.系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p><p>5.通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预</p><p>6.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p><p>7.进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉</p><p>8.进程适应于多核、多机分布；线程适用于多核</p><p>进程间通信的方式：</p><p>进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。</p><p>1.管道：</p><p>管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</p><p>1.1 普通管道PIPE：</p><p>1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端</p><p>2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</p><p>3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p><p>1.2 命名管道FIFO：</p><p>1)FIFO可以在无关的进程之间交换数据</p><p>2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p><p>\2. 系统IPC：</p><p>2.1 消息队列</p><p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p><p>特点：</p><p>1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p><p>2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p><p>3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p><p>2.2 信号量semaphore</p><p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p><p>特点：</p><p>1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</p><p>2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</p><p>3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p><p>4)支持信号量组。</p><p>2.3 信号signal</p><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p>2.4 共享内存（Shared Memory）</p><p>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等</p><p>特点：</p><p>1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取</p><p>2)因为多个进程可以同时操作，所以需要进行同步</p><p>3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</p><p>3.套接字SOCKET：</p><p>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</p><p>线程间通信的方式:</p><p>临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p><p>互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p><p>信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p><p>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p><h2 id="●-请你说一说Linux虚拟地址空间"><a href="#●-请你说一说Linux虚拟地址空间" class="headerlink" title="● 请你说一说Linux虚拟地址空间"></a>● 请你说一说Linux虚拟地址空间</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存。</p><p>虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p><p>请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</p><p>虚拟内存的好处：</p><p>1.扩大地址空间；</p><p>2.内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。</p><p>3.公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。</p><p>4.当进程通信时，可采用虚存共享的方式实现。</p><p>5.当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存</p><p>6.虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高</p><p>7.在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片</p><p>虚拟内存的代价：</p><p>1.虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存</p><p>2.虚拟地址到物理地址的转换，增加了指令的执行时间。</p><p>3.页面的换入换出需要磁盘I/O，这是很耗时的</p><p>4.如果一页中只有一部分数据，会浪费内存。</p><h2 id="●-请你说一说操作系统中的程序的内存结构"><a href="#●-请你说一说操作系统中的程序的内存结构" class="headerlink" title="● 请你说一说操作系统中的程序的内存结构"></a>● 请你说一说操作系统中的程序的内存结构</h2><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552469062814_B7994596FDDB98A22E80E1D2556A6153" alt="img"></p><h2 id="●-请你说一说操作系统中的缺页中断"><a href="#●-请你说一说操作系统中的缺页中断" class="headerlink" title="● 请你说一说操作系统中的缺页中断"></a>● 请你说一说操作系统中的缺页中断</h2><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。</p><p>缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</p><p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p><p>1、保护CPU现场</p><p>2、分析中断原因</p><p>3、转入缺页中断处理程序进行处理</p><p>4、恢复CPU现场，继续执行</p><p>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：</p><p>1、在指令执行期间产生和处理缺页中断信号</p><p>2、一条指令在执行期间，可能产生多次缺页中断</p><p>3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。</p><h2 id="●-请你回答一下fork和vfork的区别"><a href="#●-请你回答一下fork和vfork的区别" class="headerlink" title="● 请你回答一下fork和vfork的区别"></a>● 请你回答一下fork和vfork的区别</h2><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>fork的基础知识：</p><p>fork:创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p><p>#include &lt;sys/types.h&gt;</p><p>#include &lt;unistd.h&gt;</p><p>pid_t fork(void);</p><p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p><p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p><p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p><p>vfork的基础知识：</p><p>在实现写时复制之前，Unix的设计者们就一直很关注在fork后立刻执行exec所造成的地址空间的浪费。BSD的开发者们在3.0的BSD系统中引入了vfork( )系统调用。</p><p>#include &lt;sys/types.h&gt;</p><p>#include &lt;unistd.h&gt;</p><p>pid_t vfork(void);</p><p>除了子进程必须要立刻执行一次对exec的系统调用，或者调用_exit( )退出，对vfork( )的成功调用所产生的结果和fork( )是一样的。vfork( )会挂起父进程直到子进程终止或者运行了一个新的可执行文件的映像。通过这样的方式，vfork( )避免了地址空间的按页复制。在这个过程中，父进程和子进程共享相同的地址空间和页表项。实际上vfork( )只完成了一件事：复制内部的内核数据结构。因此，子进程也就不能修改地址空间中的任何内存。</p><p>vfork( )是一个历史遗留产物，Linux本不应该实现它。需要注意的是，即使增加了写时复制，vfork( )也要比fork( )快，因为它没有进行页表项的复制。然而，写时复制的出现减少了对于替换fork( )争论。实际上，直到2.2.0内核，vfork( )只是一个封装过的fork( )。因为对vfork( )的需求要小于fork( )，所以vfork( )的这种实现方式是可行的。</p><p>补充知识点：写时复制</p><p>Linux采用了写时复制的方法，以减少fork时对父进程空间进程整体复制带来的开销。</p><p>写时复制是一种采取了惰性优化方法来避免复制时的系统开销。它的前提很简单：如果有多个进程要读取它们自己的那部门资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。只要没有进程要去修改自己的“副本”，就存在着这样的幻觉：每个进程好像独占那个资源。从而就避免了复制带来的负担。如果一个进程要修改自己的那份资源“副本”，那么就会复制那份资源，并把复制的那份提供给进程。不过其中的复制对进程来说是透明的。这个进程就可以修改复制后的资源了，同时其他的进程仍然共享那份没有修改过的资源。所以这就是名称的由来：在写入时进行复制。</p><p>写时复制的主要好处在于：如果进程从来就不需要修改资源，则不需要进行复制。惰性算法的好处就在于它们尽量推迟代价高昂的操作，直到必要的时刻才会去执行。</p><p>在使用虚拟内存的情况下，写时复制（Copy-On-Write）是以页为基础进行的。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。在fork( )调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。</p><p>写时复制在内核中的实现非常简单。与内核页相关的数据结构可以被标记为只读和写时复制。如果有进程试图修改一个页，就会产生一个缺页中断。内核处理缺页中断的方式就是对该页进行一次透明复制。这时会清除页面的COW属性，表示着它不再被共享。</p><p>现代的计算机系统结构中都在内存管理单元（MMU）提供了硬件级别的写时复制支持，所以实现是很容易的。</p><p>在调用fork( )时，写时复制是有很大优势的。因为大量的fork之后都会跟着执行exec，那么复制整个父进程地址空间中的内容到子进程的地址空间完全是在浪费时间：如果子进程立刻执行一个新的二进制可执行文件的映像，它先前的地址空间就会被交换出去。写时复制可以对这种情况进行优化。</p><p>fork和vfork的区别：</p><p>\1. fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段</p><p>\2. fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。</p><p>\3. vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</p><p>4.当需要改变共享数据段中变量的值，则拷贝父进程。</p><h2 id="●-请问如何修改文件最大句柄数？"><a href="#●-请问如何修改文件最大句柄数？" class="headerlink" title="● 请问如何修改文件最大句柄数？"></a>● 请问如何修改文件最大句柄数？</h2><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>linux默认最大文件句柄数是1024个，在linux服务器文件并发量比较大的情况下，系统会报”too many open files”的错误。故在linux服务器高并发调优时，往往需要预先调优Linux参数，修改Linux最大文件句柄数。</p><p>有两种方法：</p><p>\1. ulimit -n &lt;可以同时打开的文件数&gt;，将当前进程的最大句柄数修改为指定的参数（注：该方法只针对当前进程有效，重新打开一个shell或者重新开启一个进程，参数还是之前的值）</p><p>首先用ulimit -a查询Linux相关的参数，如下所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">core</span> <span class="hljs-selector-tag">file</span> <span class="hljs-selector-tag">size</span>          (blocks, -c) <span class="hljs-selector-tag">0</span><br><span class="hljs-selector-tag">data</span> <span class="hljs-selector-tag">seg</span> <span class="hljs-selector-tag">size</span>           (kbytes, -d) <span class="hljs-selector-tag">unlimited</span><br><span class="hljs-selector-tag">scheduling</span> <span class="hljs-selector-tag">priority</span>             (-e) <span class="hljs-selector-tag">0</span><br><span class="hljs-selector-tag">file</span> <span class="hljs-selector-tag">size</span>               (blocks, -f) <span class="hljs-selector-tag">unlimited</span><br><span class="hljs-selector-tag">pending</span> <span class="hljs-selector-tag">signals</span>                 (-i) <span class="hljs-selector-tag">94739</span><br><span class="hljs-selector-tag">max</span> <span class="hljs-selector-tag">locked</span> <span class="hljs-selector-tag">memory</span>       (kbytes, -l) <span class="hljs-selector-tag">64</span><br><span class="hljs-selector-tag">max</span> <span class="hljs-selector-tag">memory</span> <span class="hljs-selector-tag">size</span>         (kbytes, -m) <span class="hljs-selector-tag">unlimited</span><br><span class="hljs-selector-tag">open</span> <span class="hljs-selector-tag">files</span>                      (-n) <span class="hljs-selector-tag">1024</span><br><span class="hljs-selector-tag">pipe</span> <span class="hljs-selector-tag">size</span>            (<span class="hljs-number">512</span> bytes, -p) <span class="hljs-selector-tag">8</span><br><span class="hljs-selector-tag">POSIX</span> <span class="hljs-selector-tag">message</span> <span class="hljs-selector-tag">queues</span>     (bytes, -q) <span class="hljs-selector-tag">819200</span><br><span class="hljs-selector-tag">real-time</span> <span class="hljs-selector-tag">priority</span>              (-r) <span class="hljs-selector-tag">0</span><br><span class="hljs-selector-tag">stack</span> <span class="hljs-selector-tag">size</span>              (kbytes, -s) <span class="hljs-selector-tag">8192</span><br><span class="hljs-selector-tag">cpu</span> <span class="hljs-selector-tag">time</span>               (seconds, -t) <span class="hljs-selector-tag">unlimited</span><br><span class="hljs-selector-tag">max</span> <span class="hljs-selector-tag">user</span> <span class="hljs-selector-tag">processes</span>              (-u) <span class="hljs-selector-tag">94739</span><br><span class="hljs-selector-tag">virtual</span> <span class="hljs-selector-tag">memory</span>          (kbytes, -v) <span class="hljs-selector-tag">unlimited</span><br><span class="hljs-selector-tag">file</span> <span class="hljs-selector-tag">locks</span>                      (-x) <span class="hljs-selector-tag">unlimited</span><br></code></pre></td></tr></table></figure><p>其中，open files就是最大文件句柄数，默认是1024个。</p><p>修改Linux最大文件句柄数：  ulimit -n 2048， 将最大句柄数修改为 2048个。</p><p>\2. 对所有进程都有效的方法，修改Linux系统参数</p><p>vi /etc/security/limits.conf 添加</p><p>*　　soft　　nofile　　65536</p><p>*　　hard　　nofile　　65536</p><p>将最大句柄数改为65536</p><p>修改以后保存，注销当前用户，重新登录，修改后的参数就生效了</p><h2 id="●-请你说一说并发-concurrency-和并行-parallelism"><a href="#●-请你说一说并发-concurrency-和并行-parallelism" class="headerlink" title="● 请你说一说并发(concurrency)和并行(parallelism)"></a>● 请你说一说并发(concurrency)和并行(parallelism)</h2><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。</p><p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。</p><h2 id="●-请问MySQL的端口号是多少，如何修改这个端口号"><a href="#●-请问MySQL的端口号是多少，如何修改这个端口号" class="headerlink" title="● 请问MySQL的端口号是多少，如何修改这个端口号"></a>● 请问MySQL的端口号是多少，如何修改这个端口号</h2><h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>查看端口号：</p><p>使用命令show global variables like ‘port’;查看端口号 ，mysql的默认端口是3306。（补充：sqlserver默认端口号为：1433；oracle默认端口号为：1521；DB2默认端口号为：5000；PostgreSQL默认端口号为：5432）</p><p>修改端口号：</p><p>修改端口号：编辑/etc/my.cnf文件，早期版本有可能是my.conf文件名，增加端口参数，并且设定端口，注意该端口未被使用，保存退出。</p><h2 id="●-请你说一说操作系统中的页表寻址"><a href="#●-请你说一说操作系统中的页表寻址" class="headerlink" title="● 请你说一说操作系统中的页表寻址"></a>● 请你说一说操作系统中的页表寻址</h2><h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>页式内存管理，内存分成固定长度的一个个页片。操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表，页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定。一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。</p><p>Linux最初的两级页表机制：</p><p>两级分页机制将32位的虚拟空间分成三段，低十二位表示页内偏移，高20分成两段分别表示两级页表的偏移。</p><p>* PGD(Page Global Directory): 最高10位，全局页目录表索引</p><p>* PTE(Page Table Entry)：中间10位，页表入口索引</p><p>当在进行地址转换时，结合在CR3寄存器中存放的页目录(page directory, PGD)的这一页的物理地址，再加上从虚拟地址中抽出高10位叫做页目录表项(内核也称这为pgd)的部分作为偏移, 即定位到可以描述该地址的pgd；从该pgd中可以获取可以描述该地址的页表的物理地址，再加上从虚拟地址中抽取中间10位作为偏移, 即定位到可以描述该地址的pte；在这个pte中即可获取该地址对应的页的物理地址, 加上从虚拟地址中抽取的最后12位，即形成该页的页内偏移, 即可最终完成从虚拟地址到物理地址的转换。从上述过程中，可以看出，对虚拟地址的分级解析过程，实际上就是不断深入页表层次，逐渐定位到最终地址的过程，所以这一过程被叫做page talbe walk。</p><p>Linux的三级页表机制：</p><p>当X86引入物理地址扩展(Pisycal Addrress Extension, PAE)后，可以支持大于4G的物理内存(36位），但虚拟地址依然是32位，原先的页表项不适用，它实际多4 bytes被扩充到8 bytes，这意味着，每一页现在能存放的pte数目从1024变成512了(4k/8)。相应地，页表层级发生了变化，Linus新增加了一个层级，叫做页中间目录(page middle directory, PMD), 变成：</p><p>字段            描述                        位数</p><p>cr3            指向一个PDPT            crs寄存器存储</p><p>PGD        指向PDPT中4个项中的一个    位31~30</p><p>PMD        指向页目录中512项中的一个    位29~21</p><p>PTE            指向页表中512项中的一个    位20~12</p><p>page offset    4KB页中的偏移            位11~0</p><p>现在就同时存在2级页表和3级页表，在代码管理上肯定不方便。巧妙的是，Linux采取了一种抽象方法：所有架构全部使用3级页表: 即PGD -&gt; PMD -&gt; PTE。那只使用2级页表(如非PAE的X86)怎么办？</p><p>办法是针对使用2级页表的架构，把PMD抽象掉，即虚设一个PMD表项。这样在page table walk过程中，PGD本直接指向PTE的，现在不了，指向一个虚拟的PMD，然后再由PMD指向PTE。这种抽象保持了代码结构的统一。</p><p>Linux的四级页表机制：</p><p>硬件在发展，3级页表很快又捉襟见肘了，原因是64位CPU出现了, 比如X86_64， 它的硬件是实实在在支持4级页表的。它支持48位的虚拟地址空间1。如下：</p><p>字段            描述                        位数</p><p>PML4        指向一个PDPT            位47~39</p><p>PGD        指向PDPT中4个项中的一个    位38~30</p><p>PMD        指向页目录中512项中的一个    位29~21</p><p>PTE            指向页表中512项中的一个    位20~12</p><p>page offset    4KB页中的偏移            位11~0</p><p>Linux内核针为使用原来的3级列表(PGD-&gt;PMD-&gt;PTE)，做了折衷。即采用一个唯一的，共享的顶级层次，叫PML4。这个PML4没有编码在地址中，这样就能套用原来的3级列表方案了。不过代价就是，由于只有唯一的PML4, 寻址空间被局限在(239=)512G, 而本来PML4段有9位, 可以支持512个PML4表项的。现在为了使用3级列表方案，只能限制使用一个， 512G的空间很快就又不够用了，解决方案呼之欲出。</p><p>在2004年10月，当时的X86_64架构代码的维护者Andi Kleen提交了一个叫做4level page tables for Linux的PATCH系列，为Linux内核带来了4级页表的支持。在他的解决方案中，不出意料地，按照X86_64规范，新增了一个PML4的层级, 在这种解决方案中，X86_64拥一个有512条目的PML4, 512条目的PGD, 512条目的PMD, 512条目的PTE。对于仍使用3级目录的架构来说，它们依然拥有一个虚拟的PML4,相关的代码会在编译时被优化掉。 这样，就把Linux内核的3级列表扩充为4级列表。这系列PATCH工作得不错，不久被纳入Andrew Morton的-mm树接受测试。不出意外的话，它将在v2.6.11版本中释出。但是，另一个知名开发者Nick Piggin提出了一些看法，他认为Andi的Patch很不错，不过他认为最好还是把PGD作为第一级目录，把新增加的层次放在中间，并给出了他自己的Patch:alternate 4-level page tables patches。Andi更想保持自己的PATCH, 他认为Nick不过是玩了改名的游戏，而且他的PATCH经过测试很稳定，快被合并到主线了，不宜再折腾。不过Linus却表达了对Nick Piggin的支持，理由是Nick的做法conceptually least intrusive。毕竟作为Linux的扛把子，稳定对于Linus来说意义重大。最终，不意外地，最后Nick Piggin的PATCH在v2.6.11版本中被合并入主线。在这种方案中，4级页表分别是：PGD -&gt; PUD -&gt; PMD -&gt; PTE。</p><h2 id="●-请你说一说有了进程，为什么还要有线程？"><a href="#●-请你说一说有了进程，为什么还要有线程？" class="headerlink" title="● 请你说一说有了进程，为什么还要有线程？"></a>● 请你说一说有了进程，为什么还要有线程？</h2><h3 id="参考回答：-9"><a href="#参考回答：-9" class="headerlink" title="参考回答："></a>参考回答：</h3><p>线程产生的原因：</p><p>进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：</p><p>进程在同一时间只能干一件事</p><p>进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。</p><p>因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。和进程相比，线程的优势如下：</p><p>从资源上来讲，线程是一种非常”节俭”的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。</p><p>从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。（</p><p>从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。</p><p>除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：</p><p>1、使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</p><p>2、改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。</p><h2 id="●-请问单核机器上写多线程程序，是否需要考虑加锁，为什么？"><a href="#●-请问单核机器上写多线程程序，是否需要考虑加锁，为什么？" class="headerlink" title="● 请问单核机器上写多线程程序，是否需要考虑加锁，为什么？"></a>● 请问单核机器上写多线程程序，是否需要考虑加锁，为什么？</h2><h3 id="参考回答：-10"><a href="#参考回答：-10" class="headerlink" title="参考回答："></a>参考回答：</h3><p>在单核机器上写多线程程序，仍然需要线程锁。因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突。</p><h2 id="●-请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"><a href="#●-请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的" class="headerlink" title="● 请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"></a>● 请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的</h2><h3 id="参考回答：-11"><a href="#参考回答：-11" class="headerlink" title="参考回答："></a>参考回答：</h3><p>线程在切换的过程中需要保存当前线程Id、线程状态、堆栈、寄存器状态等信息。其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：</p><p>SP:堆栈指针，指向当前栈的栈顶地址</p><p>PC:程序计数器，存储下一条将要执行的指令</p><p>EAX:累加寄存器，用于加法乘法的缺省寄存器</p><h2 id="●-请你说一说线程间的同步方式，最好说出具体的系统调用"><a href="#●-请你说一说线程间的同步方式，最好说出具体的系统调用" class="headerlink" title="● 请你说一说线程间的同步方式，最好说出具体的系统调用"></a>● 请你说一说线程间的同步方式，最好说出具体的系统调用</h2><h3 id="参考回答：-12"><a href="#参考回答：-12" class="headerlink" title="参考回答："></a>参考回答：</h3><p>信号量</p><p>信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：</p><p>P(SV):如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程。</p><p>V(SV)：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1。</p><p>其系统调用为：</p><p>sem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。</p><p>sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。</p><p>互斥量</p><p>互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区      时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：</p><p>pthread_mutex_init:初始化互斥锁</p><p>pthread_mutex_destroy：销毁互斥锁</p><p>pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。</p><p>pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁。</p><p>条件变量</p><p>条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用 signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：</p><p>pthread_cond_init:初始化条件变量</p><p>pthread_cond_destroy：销毁条件变量</p><p>pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。</p><p>pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。</p><h2 id="●-请你说一下多线程和多进程的不同"><a href="#●-请你说一下多线程和多进程的不同" class="headerlink" title="● 请你说一下多线程和多进程的不同"></a>● 请你说一下多线程和多进程的不同</h2><h3 id="参考回答：-13"><a href="#参考回答：-13" class="headerlink" title="参考回答："></a>参考回答：</h3><p>进程是资源分配的最小单位，而线程时CPU调度的最小单位。多线程之间共享同一个进程的地址空间，线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存少，适用于多核分布式系统，但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程也终止，程序可靠性弱。而多进程间拥有各自独立的运行地址空间，进程间不会相互影响，程序可靠性强，但是进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单，适用于多核、多机分布。</p><h2 id="●-请你说一说进程和线程的区别"><a href="#●-请你说一说进程和线程的区别" class="headerlink" title="● 请你说一说进程和线程的区别"></a>● 请你说一说进程和线程的区别</h2><h3 id="参考回答：-14"><a href="#参考回答：-14" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。</p><p>2）进程有独立的系统资源，而同一进程内的线程共享进程的大部分系统资源,包括堆、代码段、数据段，每个线程只拥有一些在运行中必不可少的私有属性，比如tcb,线程Id,栈、寄存器。</p><p>3）一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也死掉。</p><p>4）进程在创建、切换和销毁时开销比较大，而线程比较小。进程创建的时候需要分配系统资源，而销毁的的时候需要释放系统资源。进程切换需要分两步：切换页目录、刷新TLB以使用新的地址空间；切换内核栈和硬件上下文（寄存器）；而同一进程的线程间逻辑地址空间是一样的，不需要切换页目录、刷新TLB。</p><p>5）进程间通信比较复杂，而同一进程的线程由于共享代码段和数据段，所以通信比较容易。</p><h2 id="●-游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？"><a href="#●-游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？" class="headerlink" title="● 游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？"></a>● 游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？</h2><h3 id="参考回答：-15"><a href="#参考回答：-15" class="headerlink" title="参考回答："></a>参考回答：</h3><p>游戏服务器应该为每个用户开辟一个进程。因为同一进程间的线程会相互影响，一个线程死掉会影响其他线程，从而导致进程崩溃。因此为了保证不同用户之间不会相互影响，应该为每个用户开辟一个进程</p><h2 id="●-请你说一说OS缺页置换算法"><a href="#●-请你说一说OS缺页置换算法" class="headerlink" title="● 请你说一说OS缺页置换算法"></a>● 请你说一说OS缺页置换算法</h2><h3 id="参考回答：-16"><a href="#参考回答：-16" class="headerlink" title="参考回答："></a>参考回答：</h3><p>当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：</p><p>先进先出(FIFO)算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。</p><p>最近最少使用（LRU）算法: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。</p><p>当前最常采用的就是LRU算法。</p><h2 id="●-请你说一说进程和线程区别"><a href="#●-请你说一说进程和线程区别" class="headerlink" title="● 请你说一说进程和线程区别"></a>● 请你说一说进程和线程区别</h2><h3 id="参考回答：-17"><a href="#参考回答：-17" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。</p><p>2）进程有独立的系统资源，而同一进程内的线程共享进程的大部分系统资源,包括堆、代码段、数据段，每个线程只拥有一些在运行中必不可少的私有属性，比如tcb,线程Id,栈、寄存器。</p><p>3）一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也死掉。</p><p>4）进程在创建、切换和销毁时开销比较大，而线程比较小。进程创建的时候需要分配系统资源，而销毁的的时候需要释放系统资源。进程切换需要分两步：切换页目录、刷新TLB以使用新的地址空间；切换内核栈和硬件上下文（寄存器）；而同一进程的线程间逻辑地址空间是一样的，不需要切换页目录、刷新TLB。</p><p>5）进程间通信比较复杂，而同一进程的线程由于共享代码段和数据段，所以通信比较容易。</p><h2 id="●-请你说一下多进程和多线程的使用场景"><a href="#●-请你说一下多进程和多线程的使用场景" class="headerlink" title="● 请你说一下多进程和多线程的使用场景"></a>● 请你说一下多进程和多线程的使用场景</h2><h3 id="参考回答：-18"><a href="#参考回答：-18" class="headerlink" title="参考回答："></a>参考回答：</h3><p>多进程模型的优势是CPU</p><p>多线程模型主要优势为线程间切换代价较小，因此适用于I/O密集型的工作场景，因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁的切换线程。同时，多线程模型也适用于单机多核分布式场景。</p><p>多进程模型，适用于CPU密集型。同时，多进程模型也适用于多机分布式场景中，易于多机扩展。</p><h2 id="●-请你说一说死锁发生的条件以及如何解决死锁"><a href="#●-请你说一说死锁发生的条件以及如何解决死锁" class="headerlink" title="● 请你说一说死锁发生的条件以及如何解决死锁"></a>● 请你说一说死锁发生的条件以及如何解决死锁</h2><h3 id="参考回答：-19"><a href="#参考回答：-19" class="headerlink" title="参考回答："></a>参考回答：</h3><p>死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下：</p><p>互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；</p><p>请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源</p><p>不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</p><p>环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链</p><p>解决死锁的方法即破坏上述四个条件之一，主要方法如下：</p><p>资源一次性分配，从而剥夺请求和保持条件</p><p>可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件</p><p>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件</p><h2 id="●-请问虚拟内存和物理内存怎么对应"><a href="#●-请问虚拟内存和物理内存怎么对应" class="headerlink" title="● 请问虚拟内存和物理内存怎么对应"></a>● 请问虚拟内存和物理内存怎么对应</h2><h3 id="参考回答：-20"><a href="#参考回答：-20" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、概念：</p><p>物理地址(physical address)</p><p>用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。</p><p>虽然可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽像，内存的寻址方式并不是这样。所以，说它是“与地址总线相对应”，是更贴切一些，不过抛开对物理内存寻址方式的考虑，直接把物理地址与物理的内存一一对应，也是可以接受的。也许错误的理解更利于形而上的抽像。</p><p>虚拟地址(virtual memory)</p><p>这是对整个内存（不要与机器上插那条对上号）的抽像描述。它是相对于物理内存来讲的，可以直接理解成“不直实的”，“假的”内存，例如，一个0x08000000内存地址，它并不对就物理地址上那个大数组中0x08000000 - 1那个地址元素；</p><p>之所以是这样，是因为现代操作系统都提供了一种内存管理的抽像，即虚拟内存（virtual memory）。进程使用虚拟内存中的地址，由操作系统协助相关硬件，把它“转换”成真正的物理地址。这个“转换”，是所有问题讨论的关键。</p><p>有了这样的抽像，一个程序，就可以使用比真实物理地址大得多的地址空间。甚至多个进程可以使用相同的地址。不奇怪，因为转换后的物理地址并非相同的。</p><p>——可以把连接后的程序反编译看一下，发现连接器已经为程序分配了一个地址，例如，要调用某个函数A，代码不是call A，而是call 0x0811111111 ，也就是说，函数A的地址已经被定下来了。没有这样的“转换”，没有虚拟地址的概念，这样做是根本行不通的。</p><p>2、地址转换</p><p>第一步：CPU段式管理中——逻辑地址转线性地址</p><p>CPU要利用其段式内存管理单元，先将为个逻辑地址转换成一个线程地址。</p><p>一个逻辑地址由两部份组成，【段标识符：段内偏移量】。</p><p>段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节，如图：</p><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470210037_13DB46E4DEE567FEF6756A26C5A0EC62" alt="img"></p><p>通过段标识符中的索引号从GDT或者LDT找到该段的段描述符，段描述符中的base字段是段的起始地址</p><p>段描述符：Base字段，它描述了一个段的开始位置的线性地址。</p><p>一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。</p><p>GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中。</p><p>段起始地址+ 段内偏移量 = 线性地址</p><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470239469_B327A1776BDD614C1FA189B123676D44" alt="img"></p><p>首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]，</p><p>1、看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。</p><p>2、拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，它了Base，即基地址就知道了。</p><p>3、把Base + offset，就是要转换的线性地址了。</p><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470270211_A8B080AAD8609459CD745F5E2480B919" alt="img"></p><p>第一步：页式管理——线性地址转物理地址</p><p>再利用其页式内存管理单元，转换为最终物理地址。</p><p>linux假的段式管理</p><p>Intel要求两次转换，这样虽说是兼容了，但是却是很冗余，但是这是intel硬件的要求。</p><p>其它某些硬件平台，没有二次转换的概念，Linux也需要提供一个高层抽像，来提供一个统一的界面。</p><p>所以，Linux的段式管理，事实上只是“哄骗”了一下硬件而已。</p><p>按照Intel的本意，全局的用GDT，每个进程自己的用LDT——不过Linux则对所有的进程都使用了相同的段来对指令和数据寻址。即用户数据段，用户代码段，对应的，内核中的是内核数据段和内核代码段。</p><p>在Linux下，逻辑地址与线性地址总是一致的，即逻辑地址的偏移量字段的值与线性地址的值总是相同的。</p><p>linux页式管理</p><p>CPU的页式内存管理单元，负责把一个线性地址，最终翻译为一个物理地址。</p><p>线性地址被分为以固定长度为单位的组，称为页(page)，例如一个32位的机器，线性地址最大可为4G，可以用4KB为一个页来划分，这页，整个线性地址就被划分为一个tatol_page[2^20]的大数组，共有2的20个次方个页。</p><p>另一类“页”，我们称之为物理页，或者是页框、页桢的。是分页单元把所有的物理内存也划分为固定长度的管理单位，它的长度一般与内存页是一一对应的。</p><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470300375_E395C4896EA5D7621E9211A0C3817BB5" alt="img"></p><p>每个进程都有自己的页目录，当进程处于运行态的时候，其页目录地址存放在cr3寄存器中。</p><p>每一个32位的线性地址被划分为三部份，【页目录索引(10位)：页表索引(10位)：页内偏移(12位)】</p><p>依据以下步骤进行转换：</p><p>从cr3中取出进程的页目录地址（操作系统负责在调度进程的时候，把这个地址装入对应寄存器）；</p><p>根据线性地址前十位，在数组中，找到对应的索引项，因为引入了二级管理模式，页目录中的项，不再是页的地址，而是一个页表的地址。（又引入了一个数组），页的地址被放到页表中去了。</p><p>根据线性地址的中间十位，在页表（也是数组）中找到页的起始地址；</p><p>将页的起始地址与线性地址中最后12位相加。</p><p>目的：</p><p>内存节约：如果一级页表中的一个页表条目为空，那么那所指的二级页表就根本不会存在。这表现出一种巨大的潜在节约，因为对于一个典型的程序，4GB虚拟地址空间的大部份都会是未分配的；</p><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470330729_28397F90C2D7C059A122BFF0B4DFD63A" alt="img"></p><p>32位，PGD = 10bit，PUD = PMD = 0，table = 10bit，offset = 12bit</p><p>64位，PUD和PMD ≠ 0</p><h2 id="●-请你说一说操作系统中的结构体对齐，字节对齐"><a href="#●-请你说一说操作系统中的结构体对齐，字节对齐" class="headerlink" title="● 请你说一说操作系统中的结构体对齐，字节对齐"></a>● 请你说一说操作系统中的结构体对齐，字节对齐</h2><h3 id="参考回答：-21"><a href="#参考回答：-21" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、原因：</p><p>1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p><p>2）性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p><p>2、规则</p><p>1）数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。</p><p>2）结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</p><p>3）结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。</p><p>3、定义结构体对齐</p><p>可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。</p><p>4、举例</p><p>#pragma pack(2)</p><p>struct AA {</p><p>int a;       //长度4 &gt; 2 按2对齐；偏移量为0；存放位置区间[0,3]</p><p>char b;  //长度1 &lt; 2 按1对齐；偏移量为4；存放位置区间[4]</p><p>short c;     //长度2 = 2 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</p><p>char d;  //长度1 &lt; 2 按1对齐；偏移量为7；存放位置区间[8]；共九个字节</p><p>};</p><p>#pragma pack()</p><h2 id="●-请问进程间怎么通信"><a href="#●-请问进程间怎么通信" class="headerlink" title="● 请问进程间怎么通信"></a>● 请问进程间怎么通信</h2><h3 id="参考回答：-22"><a href="#参考回答：-22" class="headerlink" title="参考回答："></a>参考回答：</h3><p>进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。</p><p>1.管道：</p><p>管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</p><p>1.1 普通管道PIPE：</p><p>1）它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端</p><p>2）它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</p><p>3）它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p><p>1.2 命名管道FIFO：</p><p>1）FIFO可以在无关的进程之间交换数据</p><p>2）FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p><p>\2. 系统IPC：</p><p>2.1 消息队列</p><p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p><p>特点：</p><p>1）消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p><p>2）消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p><p>3）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p><p>2.2 信号量semaphore</p><p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p><p>特点：</p><p>1）信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</p><p>2）信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</p><p>3）每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p><p>4）支持信号量组。</p><p>2.3 信号signal</p><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p>2.4 共享内存（Shared Memory）</p><p>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等</p><p>特点：</p><p>1）共享内存是最快的一种IPC，因为进程是直接对内存进行存取</p><p>2）因为多个进程可以同时操作，所以需要进行同步</p><p>3）信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</p><p>\3. 套接字SOCKET：</p><p>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</p><h2 id="●-请你说一下虚拟内存置换的方式"><a href="#●-请你说一下虚拟内存置换的方式" class="headerlink" title="● 请你说一下虚拟内存置换的方式"></a>● 请你说一下虚拟内存置换的方式</h2><h3 id="参考回答：-23"><a href="#参考回答：-23" class="headerlink" title="参考回答："></a>参考回答：</h3><p>比较常见的内存替换算法有：FIFO，LRU，LFU，LRU-K，2Q。</p><p>1、FIFO（先进先出淘汰算法）</p><p>思想：最近刚访问的，将来访问的可能性比较大。</p><p>实现：使用一个队列，新加入的页面放入队尾，每次淘汰队首的页面，即最先进入的数据，最先被淘汰。</p><p>弊端：无法体现页面冷热信息</p><p>2、LFU（最不经常访问淘汰算法）</p><p>思想：如果数据过去被访问多次，那么将来被访问的频率也更高。</p><p>实现：每个数据块一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。每次淘汰队尾数据块。</p><p>开销：排序开销。</p><p>弊端：缓存颠簸。</p><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470476683_909843CE326FD7243A252E09C80772B8" alt="img"></p><p>3、LRU（最近最少使用替换算法）</p><p>思想：如果数据最近被访问过，那么将来被访问的几率也更高。</p><p>实现：使用一个栈，新页面或者命中的页面则将该页面移动到栈底，每次替换栈顶的缓存页面。</p><p>优点：LRU算法对热点数据命中率是很高的。</p><p>缺陷：</p><p>1）缓存颠簸，当缓存（1，2，3）满了，之后数据访问（0，3，2，1，0，3，2，1。。。）。</p><p>2）缓存污染，突然大量偶发性的数据访问，会让内存中存放大量冷数据。</p><p>4、LRU-K（LRU-2、LRU-3）</p><p>思想：最久未使用K次淘汰算法。</p><p>LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p><p>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。</p><p>实现：</p><p>1）数据第一次被访问，加入到访问历史列表；</p><p>2）如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</p><p>3）当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</p><p>4）缓存数据队列中被再次访问后，重新排序；</p><p>5）需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</p><p>针对问题：</p><p>LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p><p>5、2Q</p><p>类似LRU-2。使用一个FIFO队列和一个LRU队列。</p><p>实现：</p><p>1）新访问的数据插入到FIFO队列；</p><p>2）如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</p><p>3）如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部；</p><p>4）如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；</p><p>5）LRU队列淘汰末尾的数据。</p><p>针对问题：LRU的缓存污染</p><p>弊端：</p><p>当FIFO容量为2时，访问负载是：ABCABCABC会退化为FIFO，用不到LRU。</p><h2 id="●-请你说一下多线程，线程同步的几种方式"><a href="#●-请你说一下多线程，线程同步的几种方式" class="headerlink" title="● 请你说一下多线程，线程同步的几种方式"></a>● 请你说一下多线程，线程同步的几种方式</h2><h3 id="参考回答：-24"><a href="#参考回答：-24" class="headerlink" title="参考回答："></a>参考回答：</h3><p>概念：</p><p>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</p><p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p><p>线程间通信的方式:</p><p>1、临界区：</p><p>通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p><p>2、互斥量 Synchronized/Lock：</p><p>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p><p>3、信号量 Semphare：</p><p>为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p><p>4、事件(信号)，Wait/Notify：</p><p>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/14/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/"/>
    <url>/2021/07/14/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/</url>
    
    <content type="html"><![CDATA[<p>d </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/"/>
    <url>/2021/07/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="题目：数据库范式"><a href="#题目：数据库范式" class="headerlink" title="题目：数据库范式"></a><strong>题目</strong>：数据库范式</h4><h4 id="参考答案："><a href="#参考答案：" class="headerlink" title="参考答案："></a><strong>参考答案</strong>：</h4><p>1 第一范式（1NF）</p><p>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。<br>所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。</p><p>2 第二范式（2NF）</p><p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。<br>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。</p><p>3 第三范式（3NF）</p><p>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。（我的理解是消除冗余）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
    <url>/2021/07/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9A%84%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h4 id="题目：数据库优化的思路"><a href="#题目：数据库优化的思路" class="headerlink" title="题目：数据库优化的思路"></a><strong>题目</strong>：数据库优化的思路</h4><h4 id="参考答案："><a href="#参考答案：" class="headerlink" title="参考答案："></a><strong>参考答案</strong>：</h4><p>这个我借鉴了慕课上关于数据库优化的课程。</p><p>1.SQL语句优化  </p><ul><li><p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。  </p></li><li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> num <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p>  可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：  </p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> num<span class="hljs-operator">=</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>  <em>liueleven</em> 的评论：</p>  <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix">不是非我杠精，关于<span class="hljs-literal">null</span>,<span class="hljs-built_in">isNull</span>,isNotNull其实是要看成本的，是否回表等因素总和考虑，才会决定是要走索引还是走全表扫描。<br></code></pre></td></tr></table></figure><p>  也给大家找了一个作者的博文（<a href="https://mp.weixin.qq.com/s/CEJFsDBizdl0SvugGX7UmQ">MySQL中IS NULL、IS NOT NULL、!=不能用索引？胡扯！</a>），仅供参考！！！</p><p>  [zhiyong0804d的意见]</p><p>  之所以未把第二条删除还是考虑可能很多人都被误导了。那这样的组织能让大家兼听则明。</p></li><li><p>很多时候用 exists 代替 in 是一个好的选择。</p></li><li><p>用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过滤。</p></li></ul><p>2.索引优化</p><pre><code>看上文索引</code></pre><p>3.数据库结构优化</p><ul><li><p>范式优化： 比如消除冗余（节省空间。。）</p></li><li><p>反范式优化：比如适当加冗余等（减少join）</p></li><li><p>拆分表：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。</p></li><li><p>拆分其实又分垂直拆分和水平拆分：</p><p>案例： 简单购物系统暂设涉及如下表：</p><p>  1.产品表（数据量10w，稳定） </p><p>  2.订单表（数据量200w，且有增长趋势）</p><p>  3.用户表 （数据量100w，且有增长趋势）</p><p>以mysql为例讲述下水平拆分和垂直拆分，mysql能容忍的数量级在百万静态数据可以到千万 </p><p><strong>垂直拆分：</strong></p><p>解决问题：表与表之间的io竞争 </p><p>不解决问题：单表中数据量增长出现的压力 </p><p>方案： 把产品表和用户表放到一个server上 订单表单独放到一个server上 </p><p><strong>水平拆分：</strong></p><p>解决问题：单表中数据量增长出现的压力 </p><p>不解决问题：表与表之间的io争夺</p><p>方案：<strong>用户表</strong> 通过性别拆分为男用户表和女用户表，<strong>订单表</strong> 通过已完成和完成中拆分为已完成订单和未完成订单，<strong>产品表</strong> 未完成订单放一个server上，已完成订单表盒男用户表放一个server上，女用户表放一个server上(女的爱购物 哈哈)。</p></li></ul><p>4.服务器硬件优化</p><p>这个么多花钱咯！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7%E5%8F%8A%E5%90%AB%E4%B9%89/"/>
    <url>/2021/07/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7%E5%8F%8A%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h4 id="题目：数据库事务的四个特性及含义"><a href="#题目：数据库事务的四个特性及含义" class="headerlink" title="题目：数据库事务的四个特性及含义"></a><strong>题目</strong>：数据库事务的四个特性及含义</h4><h4 id="参考答案："><a href="#参考答案：" class="headerlink" title="参考答案："></a><strong>参考答案</strong>：</h4><p>数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)</p><ul><li><p>原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p>一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</p></li><li><p>隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。</p></li><li><p>持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/14/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2021/07/14/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="●-请你说一说数据库索引"><a href="#●-请你说一说数据库索引" class="headerlink" title="● 请你说一说数据库索引"></a>● 请你说一说数据库索引</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。</p><p>索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。</p><h2 id="●-请你说一说数据库事务"><a href="#●-请你说一说数据库事务" class="headerlink" title="● 请你说一说数据库事务"></a>● 请你说一说数据库事务</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。</p><h2 id="●-请你说一说数据库事务隔离"><a href="#●-请你说一说数据库事务隔离" class="headerlink" title="● 请你说一说数据库事务隔离"></a>● 请你说一说数据库事务隔离</h2><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p><h2 id="●-请你说一说inner-join和left-join"><a href="#●-请你说一说inner-join和left-join" class="headerlink" title="● 请你说一说inner join和left join"></a>● 请你说一说inner join和left join</h2><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录</p><h2 id="●-请你聊一聊数据库事物的一致性"><a href="#●-请你聊一聊数据库事物的一致性" class="headerlink" title="● 请你聊一聊数据库事物的一致性"></a>● 请你聊一聊数据库事物的一致性</h2><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。</p><p>事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。</p><p>1）原子性（Atomicity）</p><p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，[删删删]因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><p>2）一致性（Consistency）</p><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p><p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p><p>3）隔离性（Isolation）</p><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p><p>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p><p>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。</p><p>不同的隔离级别：</p><p>Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。</p><p>Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。</p><p>Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。</p><p>Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。</p><p>4）持久性（Durability）</p><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p><p>例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p><h2 id="●-请你说说索引是什么，多加索引一定会好吗"><a href="#●-请你说说索引是什么，多加索引一定会好吗" class="headerlink" title="● 请你说说索引是什么，多加索引一定会好吗"></a>● 请你说说索引是什么，多加索引一定会好吗</h2><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、索引</p><p>数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列的值进行排序的一种结构。</p><p>DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。</p><p>优点：</p><p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p><p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p><p>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p><p>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p><p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p>缺点：</p><p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p><p>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p><p>2、添加索引原则</p><p>在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p><p>只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p><p>定义为text、image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</p><p>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p><h2 id="●-请你说一下数据库事务以及四个特性"><a href="#●-请你说一下数据库事务以及四个特性" class="headerlink" title="● 请你说一下数据库事务以及四个特性"></a>● 请你说一下数据库事务以及四个特性</h2><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。</p><p>事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。</p><p>\1. 原子性（Atomicity）</p><p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，[删删删]因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><p>\2. 一致性（Consistency）</p><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p><p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p><p>\3. 隔离性（Isolation）</p><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p><p>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p><p>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</p><p>这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。</p><p>不同的隔离级别：</p><p>Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。</p><p>Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。</p><p>Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。</p><p>Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。</p><p>\4. 持久性（Durability）</p><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p><p>例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p><h2 id="●-请你说一说数据库的三大范式"><a href="#●-请你说一说数据库的三大范式" class="headerlink" title="● 请你说一说数据库的三大范式"></a>● 请你说一说数据库的三大范式</h2><h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>第一范式：当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式，即属性不可分</p><p>第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式</p><p>第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，即非主属性不传递依赖于键码</p><h2 id="●-请你介绍一下数据库的ACID特性"><a href="#●-请你介绍一下数据库的ACID特性" class="headerlink" title="● 请你介绍一下数据库的ACID特性"></a>● 请你介绍一下数据库的ACID特性</h2><h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1)原子性：事务被视为不可分割的最小单元，事物的所有操作要不成功，要不失败回滚，而回滚可以通过日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作。</p><p>2)一致性：数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p><p>3)隔离性：一个事务所做的修改在最终提交以前，对其他事务是可不见的。</p><p>4)持久性：一旦事务提交，则其所做的修改将会永远保存到数据库中。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%863/"/>
    <url>/2021/07/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%863/</url>
    
    <content type="html"><![CDATA[<h2 id="请你来说一说协程"><a href="#请你来说一说协程" class="headerlink" title="请你来说一说协程"></a>请你来说一说协程</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、概念：</p><p>协程，又称微线程，纤程，英文名Coroutine。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p><p>例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def A() :<br><span class="hljs-builtin-name">print</span> <span class="hljs-string">&#x27;1&#x27;</span><br><span class="hljs-builtin-name">print</span> <span class="hljs-string">&#x27;2&#x27;</span><br><span class="hljs-builtin-name">print</span> <span class="hljs-string">&#x27;3&#x27;</span><br>def B() :<br><span class="hljs-builtin-name">print</span> <span class="hljs-string">&#x27;x&#x27;</span><br><span class="hljs-builtin-name">print</span> <span class="hljs-string">&#x27;y&#x27;</span><br><span class="hljs-builtin-name">print</span> <span class="hljs-string">&#x27;z&#x27;</span><br></code></pre></td></tr></table></figure><p>由协程运行结果可能是12x3yz。在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A。但协程的特点在于是一个线程执行。</p><p>2）协程和线程区别</p><p>那和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p><p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p><p>3）其他</p><p>在协程上利用多核CPU呢——多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p><p>Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。</p><h2 id="●-系统调用是什么，你用过哪些系统调用"><a href="#●-系统调用是什么，你用过哪些系统调用" class="headerlink" title="● 系统调用是什么，你用过哪些系统调用"></a>● 系统调用是什么，你用过哪些系统调用</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）概念：</p><p>在计算机中，系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供了用户程序与操作系统之间的接口（即系统调用是用户程序和内核交互的接口）。</p><p>操作系统中的状态分为管态（核心态）和目态（用户态）。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。特权指令：一类只能在核心态下运行而不能在用户态下运行的特殊指令。不同的操作系统特权指令会有所差异，但是一般来说主要是和硬件相关的一些指令。用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用接口使用系统调用。</p><p>应用程序有时会需要一些危险的、权限很高的指令，如果把这些权限放心地交给用户程序是很危险的(比如一个进程可能修改另一个进程的内存区，导致其不能运行)，但是又不能完全不给这些权限。于是有了系统调用，危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。另外，计算机硬件的资源是有限的，为了更好的管理这些资源，所有的资源都由操作系统控制，进程只能向操作系统请求这些资源。操作系统是这些资源的唯一入口，这个入口就是系统调用。</p><p>2）系统调用举例：</p><p>对文件进行写操作，程序向打开的文件写入字符串“hello world”，open和write都是系统调用。如下：</p><p><a href="https://www.nowcoder.com/tutorial/93/675fd4af3ab34b2db0ae650855aa52d5#">复制代码</a></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs r">`#include&lt;stdio.h&gt;``#include&lt;stdlib.h&gt;``#include&lt;string.h&gt;``#include&lt;errno.h&gt;``#include&lt;unistd.h&gt;``#include&lt;sys/types.h&gt;``#include&lt;sys/stat.h&gt;``#include&lt;fcntl.h&gt;``int` `main(``int` `argc, ``char` `*argv[])``&#123;``    ``if` `(argc&lt;``<span class="hljs-number">2</span>``)``        ``<span class="hljs-built_in">return</span>` `0``;``    ``//用读写追加方式打开一个已经存在的文件``    ``int` `fd = open(argv[``1``], O_RDWR | O_APPEND);``    ``<span class="hljs-keyword">if</span>` `(fd == -``1``)``    ``&#123;``        ``printf(``<span class="hljs-string">&quot;error is %s\n&quot;</span>``, strerror(errno));``    ``&#125;``    ``<span class="hljs-keyword">else</span>``    ``&#123;``        ``//打印文件描述符号``        ``printf(``<span class="hljs-string">&quot;success fd = %d\n&quot;</span>``, fd);``        ``char` `buf[``100``];``        ``memset(buf, ``0``, sizeof(buf));``        ``strcpy(buf, ``<span class="hljs-string">&quot;hello world\n&quot;</span>``);``        ``write(fd, buf, strlen(buf));``        ``close(fd);``    ``&#125;``    ``<span class="hljs-built_in">return</span>` `0``;``&#125;`<br></code></pre></td></tr></table></figure><p>还有写数据write，创建进程fork，vfork等都是系统调用。</p><h2 id="●-请你来手写一下fork调用示例"><a href="#●-请你来手写一下fork调用示例" class="headerlink" title="● 请你来手写一下fork调用示例"></a>● 请你来手写一下fork调用示例</h2><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、概念：</p><p>Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p><p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p><p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p><p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p><p>2、fork实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">pid_t</span> pid;<br><span class="hljs-built_in">signal</span>(SIGCHLD, SIG_IGN);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;before fork pid:%d\n&quot;</span>, <span class="hljs-built_in">getpid</span>());<br><span class="hljs-keyword">int</span> abc = <span class="hljs-number">10</span>;<br>pid = fork();<br></code></pre></td></tr></table></figure><p>if (pid == -1) {           //错误返回</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">perror(<span class="hljs-string">&quot;tile&quot;</span>)<span class="hljs-comment">;</span><br>return -<span class="hljs-number">1</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>if (pid &gt; 0) {              //父进程空间</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">abc++;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;parent:pid:%d \n&quot;</span>, getpid());<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;abc:%d \n&quot;</span>, abc);<br><span class="hljs-keyword">sleep</span>(<span class="hljs-number">20</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>else if (pid == 0) {       //子进程空间</p><p><a href="https://www.nowcoder.com/tutorial/93/675fd4af3ab34b2db0ae650855aa52d5#">复制代码</a></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs r">`abc++;``printf``(``&quot;child:%d,parent: %d\n&quot;``, getpid(), getppid());``printf``(``&quot;abc:%d&quot;``, abc);``&#125;``printf``(``&quot;fork after...\n&quot;``);`` ``&#125;`<br></code></pre></td></tr></table></figure><h2 id="●-请你来说一说用户态到内核态的转化原理"><a href="#●-请你来说一说用户态到内核态的转化原理" class="headerlink" title="● 请你来说一说用户态到内核态的转化原理"></a>● 请你来说一说用户态到内核态的转化原理</h2><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）用户态切换到内核态的3种方式</p><p>1、系统调用</p><p>这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的ine 80h中断。</p><p>2、异常</p><p>当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此。异常的内核相关程序中，也就到了内核态，比如缺页异常。</p><p>3、外围设备的中断</p><p>当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p><p>2）切换操作</p><p>从出发方式看，可以在认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一样的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断处理机制基本上是一样的，用户态切换到内核态的步骤主要包括：</p><p>1、从当前进程的描述符中提取其内核栈的ss0及esp0信息。</p><p>2、使用ss0和esp0指向的内核栈将当前进程的cs,eip，eflags，ss,esp信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。</p><p>3、将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。</p><h2 id="●-请你说一下源码到可执行文件的过程"><a href="#●-请你说一下源码到可执行文件的过程" class="headerlink" title="● 请你说一下源码到可执行文件的过程"></a>● 请你说一下源码到可执行文件的过程</h2><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）预编译</p><p>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</p><p>1、删除所有的#define，展开所有的宏定义。</p><p>2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</p><p>3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。</p><p>4、删除所有的注释，“//”和“/**/”。</p><p>5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。</p><p>6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。</p><p>2）编译</p><p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p><p>1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</p><p>2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</p><p>3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</p><p>4、优化：源代码级别的一个优化过程。</p><p>5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</p><p>6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</p><p>3）汇编</p><p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。</p><p>4）链接</p><p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p><p>1、静态链接：</p><p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p><p>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p><p>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p><p>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p><p>2、动态链接：</p><p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p><p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；</p><p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p><p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p><h2 id="●-请你来说一下微内核与宏内核"><a href="#●-请你来说一下微内核与宏内核" class="headerlink" title="● 请你来说一下微内核与宏内核"></a>● 请你来说一下微内核与宏内核</h2><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>宏内核：除了最基本的进程、线程管理、内存管理外，将文件系统，驱动，网络协议等等都集成在内核里面，例如linux内核。</p><p>优点：效率高。</p><p>缺点：稳定性差，开发过程中的bug经常会导致整个系统挂掉。</p><p>微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。</p><p>优点：稳定，驱动等的错误只会导致相应进程死掉，不会导致整个系统都崩溃</p><p>缺点：效率低。典型代表QNX，QNX的文件系统是跑在用户态的进程，称为resmgr的东西，是订阅发布机制，文件系统的错误只会导致这个守护进程挂掉。不过数据吞吐量就比较不乐观了。</p><h2 id="●-请你说一下僵尸进程"><a href="#●-请你说一下僵尸进程" class="headerlink" title="● 请你说一下僵尸进程"></a>● 请你说一下僵尸进程</h2><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）正常进程</p><p>正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。</p><p>unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息，直到父进程通过wait / waitpid来取时才释放。保存信息包括：</p><p>1进程号the process ID</p><p>2退出状态the termination status of the process</p><p>3运行时间the amount of CPU time taken by the process等</p><p>2）孤儿进程</p><p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p><p>3）僵尸进程</p><p>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</p><p>僵尸进程是一个进程必然会经过的过程：这是每个子进程在结束时都要经过的阶段。</p><p>如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。</p><p>如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p><p>危害：</p><p>如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p><p>外部消灭：</p><p>通过kill发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源</p><p>内部解决：</p><p>1、子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。</p><p>2、fork两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。</p><h2 id="●-请问GDB调试用过吗，什么是条件断点"><a href="#●-请问GDB调试用过吗，什么是条件断点" class="headerlink" title="● 请问GDB调试用过吗，什么是条件断点"></a>● 请问GDB调试用过吗，什么是条件断点</h2><h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、GDB调试</p><p>GDB 是自由软件基金会（Free Software Foundation）的软件工具之一。它的作用是协助程序员找到代码中的错误。如果没有GDB的帮助，程序员要想跟踪代码的执行流程，唯一的办法就是添加大量的语句来产生特定的输出。但这一手段本身就可能会引入新的错误，从而也就无法对那些导致程序崩溃的错误代码进行分析。</p><p>GDB的出现减轻了开发人员的负担，他们可以在程序运行的时候单步跟踪自己的代码，或者通过断点暂时中止程序的执行。此外，他们还能够随时察看变量和内存的当前状态，并监视关键的数据结构是如何影响代码运行的。</p><p>2、条件断点</p><p>条件断点是当满足条件就中断程序运行，命令：break line-or-function if expr。</p><p>例如：(gdb)break 666 if testsize==100</p><h2 id="●-请你来介绍一下5种IO模型"><a href="#●-请你来介绍一下5种IO模型" class="headerlink" title="● 请你来介绍一下5种IO模型"></a>● 请你来介绍一下5种IO模型</h2><h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1.阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</p><h2 id="●-请你说一说异步编程的事件循环"><a href="#●-请你说一说异步编程的事件循环" class="headerlink" title="● 请你说一说异步编程的事件循环"></a>● 请你说一说异步编程的事件循环</h2><h3 id="参考回答：-9"><a href="#参考回答：-9" class="headerlink" title="参考回答："></a>参考回答：</h3><p>事件循环就是不停循环等待时间的发生，然后将这个事件的所有处理器，以及他们订阅这个事件的时间顺序依次依次执行。当这个事件的所有处理器都被执行完毕之后，事件循环就会开始继续等待下一个事件的触发，不断往复。当同时并发地处理多个请求时，以上的概念也是正确的，可以这样理解：在单个的线程中，事件处理器是一个一个按顺序执行的。即如果某个事件绑定了两个处理器，那么第二个处理器会在第一个处理器执行完毕后，才开始执行。在这个事件的所有处理器都执行完毕之前，事件循环不会去检查是否有新的事件触发。在单个线程中，一切都是有顺序地一个一个地执行的！</p><h2 id="●-请你回答一下操作系统为什么要分内核态和用户态"><a href="#●-请你回答一下操作系统为什么要分内核态和用户态" class="headerlink" title="● 请你回答一下操作系统为什么要分内核态和用户态"></a>● 请你回答一下操作系统为什么要分内核态和用户态</h2><h3 id="参考回答：-10"><a href="#参考回答：-10" class="headerlink" title="参考回答："></a>参考回答：</h3><p>为了安全性。在cpu的一些指令中，有的指令如果用错，将会导致整个系统崩溃。分了内核态和用户态后，当用户需要操作这些指令时候，内核为其提供了API，可以通过系统调用陷入内核，让内核去执行这些操作。</p><h2 id="●-请你回答一下为什么要有page-cache，操作系统怎么设计的page-cache"><a href="#●-请你回答一下为什么要有page-cache，操作系统怎么设计的page-cache" class="headerlink" title="● 请你回答一下为什么要有page cache，操作系统怎么设计的page cache"></a>● 请你回答一下为什么要有page cache，操作系统怎么设计的page cache</h2><h3 id="参考回答：-11"><a href="#参考回答：-11" class="headerlink" title="参考回答："></a>参考回答：</h3><p>加快从磁盘读取文件的速率。page cache中有一部分磁盘文件的缓存，因为从磁盘中读取文件比较慢，所以读取文件先去page cache中去查找，如果命中，则不需要去磁盘中读取，大大加快读取速度。在 Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过两个数据结构来管理这些 Cache</p><h2 id="●-server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？"><a href="#●-server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？" class="headerlink" title="● server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？"></a>● server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？</h2><h3 id="参考回答：-12"><a href="#参考回答：-12" class="headerlink" title="参考回答："></a>参考回答：</h3><p>这个需要看服务端的编程模型，如果如上一个问题的回答描述的这样，则处于阻塞状态，如果使用了epoll,select等这样的io复用情况下，处于运行状态</p><h2 id="●-请问如何设计server，使得能够接收多个客户端的请求"><a href="#●-请问如何设计server，使得能够接收多个客户端的请求" class="headerlink" title="● 请问如何设计server，使得能够接收多个客户端的请求"></a>● 请问如何设计server，使得能够接收多个客户端的请求</h2><h3 id="参考回答：-13"><a href="#参考回答：-13" class="headerlink" title="参考回答："></a>参考回答：</h3><p>多线程，线程池，io复用</p><h2 id="●-就绪状态的进程在等待什么？"><a href="#●-就绪状态的进程在等待什么？" class="headerlink" title="● 就绪状态的进程在等待什么？"></a>● 就绪状态的进程在等待什么？</h2><h3 id="参考回答：-14"><a href="#参考回答：-14" class="headerlink" title="参考回答："></a>参考回答：</h3><p>被调度使用cpu的运行权</p><h2 id="●-死循环-来连接时新建线程的方法效率有点低，怎么改进？"><a href="#●-死循环-来连接时新建线程的方法效率有点低，怎么改进？" class="headerlink" title="● 死循环+来连接时新建线程的方法效率有点低，怎么改进？"></a>● 死循环+来连接时新建线程的方法效率有点低，怎么改进？</h2><h3 id="参考回答：-15"><a href="#参考回答：-15" class="headerlink" title="参考回答："></a>参考回答：</h3><p>提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。改进死循环：使用select epoll这样的技术</p><h2 id="●-请你说一下多线程的同步，锁的机制"><a href="#●-请你说一下多线程的同步，锁的机制" class="headerlink" title="● 请你说一下多线程的同步，锁的机制"></a>● 请你说一下多线程的同步，锁的机制</h2><h3 id="参考回答：-16"><a href="#参考回答：-16" class="headerlink" title="参考回答："></a>参考回答：</h3><p>同步的时候用一个互斥量，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁。如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥量加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行。</p><h2 id="●-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"><a href="#●-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？" class="headerlink" title="● 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"></a>● 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</h2><h3 id="参考回答：-17"><a href="#参考回答：-17" class="headerlink" title="参考回答："></a>参考回答：</h3><p>单核cpu，并且开了抢占可以造成这种情况。</p><h2 id="●-请问怎么实现线程池"><a href="#●-请问怎么实现线程池" class="headerlink" title="● 请问怎么实现线程池"></a>● 请问怎么实现线程池</h2><h3 id="参考回答：-18"><a href="#参考回答：-18" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1.设置一个生产者消费者队列，作为临界资源</p><h2 id="●-Linux下怎么得到一个文件的100到200行"><a href="#●-Linux下怎么得到一个文件的100到200行" class="headerlink" title="● Linux下怎么得到一个文件的100到200行"></a>● Linux下怎么得到一个文件的100到200行</h2><h3 id="参考回答：-19"><a href="#参考回答：-19" class="headerlink" title="参考回答："></a>参考回答：</h3><p>sed -n ‘100,200p’ inputfile</p><p>awk ‘NR&gt;=100&amp;&amp;NR&lt;=200{print}’ inputfile</p><p>head -200 inputfile|tail -100</p><h2 id="●-请你来说一下awk的使用"><a href="#●-请你来说一下awk的使用" class="headerlink" title="● 请你来说一下awk的使用"></a>● 请你来说一下awk的使用</h2><h3 id="参考回答：-20"><a href="#参考回答：-20" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）作用：</p><p>样式扫描和处理语言。它允许创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p><p>2）用法：</p><p>awk [-F  field-separator]  ‘commands’  input-file(s)</p><p>3）内置变量</p><table><thead><tr><th>ARGC</th><th>命令行参数个数</th></tr></thead><tbody><tr><td>ARGV</td><td>命令行参数排列</td></tr><tr><td>ENVIRON</td><td>支持队列中系统环境变量的使用</td></tr><tr><td>FILENAME</td><td>awk浏览的文件名</td></tr><tr><td>FNR</td><td>浏览文件的记录数</td></tr><tr><td>FS</td><td>设置输入域分隔符，等价于命令行 -F选项</td></tr><tr><td>NF</td><td>浏览记录的域的个数</td></tr><tr><td>NR</td><td>已读的记录数</td></tr><tr><td>OFS</td><td>输出域分隔符</td></tr><tr><td>ORS</td><td>输出记录分隔符</td></tr><tr><td>RS</td><td>控制记录分隔符</td></tr></tbody></table><p>4）实例：</p><p>1、找到当前文件夹下所有的文件和子文件夹,并显示文件大小</p><p>&gt; ls -l | awk ‘{print $5 “\t” $9}’</p><p>读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域。$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”。</p><p>2、找到当前文件夹下所有的文件和子文件夹，并显示文件大小，并显示排序</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">&gt; <span class="hljs-keyword">ls</span> -<span class="hljs-keyword">l</span> | awk &#x27;BEGIN &#123;<span class="hljs-keyword">COUNT</span> = -1; <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;BEGIN COUNT&quot;</span>&#125;<br>&#123;<span class="hljs-keyword">COUNT</span> = <span class="hljs-keyword">COUNT</span> + 1; <span class="hljs-keyword">print</span> <span class="hljs-keyword">COUNT</span><span class="hljs-string">&quot;\t&quot;</span><span class="hljs-variable">$5</span><span class="hljs-string">&quot;\t&quot;</span><span class="hljs-variable">$9&#125;</span><br>END &#123;<span class="hljs-keyword">print</span> <span class="hljs-string">&quot;END, COUNT = &quot;</span><span class="hljs-keyword">COUNT</span>&#125;&#x27;<br></code></pre></td></tr></table></figure><p>先处理BEGIN， 然后进行文本分析，进行第二个{}的操作，分析完进行END操作。</p><p>3、找到当前文件夹下所有的子文件夹,并显示排序</p><p>&gt; ls -l | awk ‘BEGIN {print “BEGIN COUNT”} /4096/{print NR”\t”$5”\t”$9}</p><p>END {print “END”}’</p><p>* /4096/ 正则匹配式子</p><p>* 使用print $NF可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段，其他以此类推。</p><h2 id="●-请你来说一下linux内核中的Timer-定时器机制"><a href="#●-请你来说一下linux内核中的Timer-定时器机制" class="headerlink" title="● 请你来说一下linux内核中的Timer 定时器机制"></a>● 请你来说一下linux内核中的Timer 定时器机制</h2><h3 id="参考回答：-21"><a href="#参考回答：-21" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）低精度时钟</p><p>Linux 2.6.16之前，内核只支持低精度时钟，内核定时器的工作方式：</p><p>1、系统启动后，会读取时钟源设备(RTC, HPET，PIT…)，初始化当前系统时间。</p><p>2、内核会根据HZ(系统定时器频率，节拍率)参数值，设置时钟事件设备，启动tick(节拍)中断。HZ表示1秒种产生多少个时钟硬件中断，tick就表示连续两个中断的间隔时间。</p><p>3、设置时钟事件设备后，时钟事件设备会定时产生一个tick中断，触发时钟中断处理函数，更新系统时钟,并检测timer wheel，进行超时事件的处理。</p><p>在上面工作方式下，Linux 2.6.16 之前，内核软件定时器采用timer wheel多级时间轮的实现机制，维护操作系统的所有定时事件。timer wheel的触发是基于系统tick周期性中断。</p><p>所以说这之前，linux只能支持ms级别的时钟，随着时钟源硬件设备的精度提高和软件高精度计时的需求，有了高精度时钟的内核设计。</p><p>2）高精度时钟</p><p>Linux 2.6.16 ，内核支持了高精度的时钟，内核采用新的定时器hrtimer，其实现逻辑和Linux 2.6.16 之前定时器逻辑区别：</p><p>hrtimer采用红黑树进行高精度定时器的管理，而不是时间轮；</p><p>高精度时钟定时器不在依赖系统的tick中断，而是基于事件触发。</p><p>旧内核的定时器实现依赖于系统定时器硬件定期的tick，基于该tick，内核会扫描timer wheel处理超时事件，会更新jiffies，wall time(墙上时间，现实时间)，process的使用时间等等工作。</p><p>新的内核不再会直接支持周期性的tick，新内核定时器框架采用了基于事件触发，而不是以前的周期性触发。新内核实现了hrtimer(high resolution timer)：于事件触发。</p><p>hrtimer的工作原理：</p><p>通过将高精度时钟硬件的下次中断触发时间设置为红黑树中最早到期的Timer 的时间，时钟到期后从红黑树中得到下一个 Timer 的到期时间，并设置硬件，如此循环反复。</p><p>在高精度时钟模式下，操作系统内核仍然需要周期性的tick中断，以便刷新内核的一些任务。hrtimer是基于事件的，不会周期性出发tick中断，所以为了实现周期性的tick中断(dynamic tick)：系统创建了一个模拟 tick 时钟的特殊 hrtimer，将其超时时间设置为一个tick时长，在超时回来后，完成对应的工作，然后再次设置下一个tick的超时时间，以此达到周期性tick中断的需求。</p><p>引入了dynamic tick，是为了能够在使用高精度时钟的同时节约能源，这样会产生tickless 情况下，会跳过一些 tick。</p><p>新内核对相关的时间硬件设备进行了统一的封装，定义了主要有下面两个结构：</p><p>时钟源设备(closk source device)：抽象那些能够提供计时功能的系统硬件，比如 RTC(Real Time Clock)、TSC(Time Stamp Counter)，HPET，ACPI PM-Timer，PIT等。不同时钟源提供的精度不一样，现在pc大都是支持高精度模式(high-resolution mode)也支持低精度模式(low-resolution mode)。</p><p>时钟事件设备(clock event device)：系统中可以触发 one-shot（单次）或者周期性中断的设备都可以作为时钟事件设备。</p><p>当前内核同时存在新旧timer wheel 和 hrtimer两套timer的实现，内核启动后会进行从低精度模式到高精度时钟模式的切换，hrtimer模拟的tick中断将驱动传统的低精度定时器系统（基于时间轮）和内核进程调度</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%862/"/>
    <url>/2021/07/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%862/</url>
    
    <content type="html"><![CDATA[<h2 id="请你讲述一下互斥锁（mutex）机制，以及互斥锁和读写锁的区别"><a href="#请你讲述一下互斥锁（mutex）机制，以及互斥锁和读写锁的区别" class="headerlink" title="请你讲述一下互斥锁（mutex）机制，以及互斥锁和读写锁的区别"></a>请你讲述一下互斥锁（mutex）机制，以及互斥锁和读写锁的区别</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、互斥锁和读写锁区别：</p><p>互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</p><p>读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</p><p>互斥锁和读写锁的区别：</p><p>1）读写锁区分读者和写者，而互斥锁不区分</p><p>2）互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</p><p>2、Linux的4种锁机制：</p><p>互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒</p><p>读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</p><p>自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。</p><p>RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。</p><h2 id="●-请回答一下进程和线程的区别"><a href="#●-请回答一下进程和线程的区别" class="headerlink" title="● 请回答一下进程和线程的区别"></a>● 请回答一下进程和线程的区别</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p><p>2、进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p><p>3、进程是资源分配的最小单位，线程是CPU调度的最小单位。</p><p>4、系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p><p>5、通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 。</p><p>6、进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p><p>7、进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉。</p><p>8、进程适应于多核、多机分布；线程适用于多核。</p><h2 id="●-请你说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞"><a href="#●-请你说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞" class="headerlink" title="● 请你说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞"></a>● 请你说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞</h2><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、进程的五种基本状态：</p><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470678794_F9BF116BD97A95A5E655DF9E1672186F" alt="img"></p><p>1）创建状态：进程正在被创建</p><p>2）就绪状态：进程被加入到就绪队列中等待CPU调度运行</p><p>3）执行状态：进程正在被运行</p><p>4）等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行。</p><p>5）终止状态：进程运行完毕</p><p>2、交换技术</p><p>当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I/0速度比处理机速度慢得多，可能出现全部进程阻塞等待I/O。</p><p>针对以上问题，提出了两种解决方法：</p><p>1）交换技术：换出一部分进程到外存，腾出内存空间。</p><p>2）虚拟存储技术：每个进程只能装入一部分程序和数据。</p><p>在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存。</p><p>从而出现了进程的挂起状态：进程被交换到外存，进程状态就成为了挂起状态。</p><p>3、活动阻塞，静止阻塞，活动就绪，静止就绪</p><p>1）活动阻塞：进程在内存，但是由于某种原因被阻塞了。</p><p>2）静止阻塞：进程在外存，同时被某种原因阻塞了。</p><p>3）活动就绪：进程在内存，处于就绪状态，只要给CPU和调度就可以直接运行。</p><p>4）静止就绪：进程在外存，处于就绪状态，只要调度到内存，给CPU和调度就可以运行。</p><p>从而出现了：</p><p>活动就绪 ——  静止就绪        （内存不够，调到外存）</p><p>活动阻塞 ——  静止阻塞        （内存不够，调到外存）</p><p>执行     ——  静止就绪         （时间片用完）</p><h2 id="●-A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？"><a href="#●-A-a-new-A-a-gt-i-10-在内核中的内存分配上发生了什么？" class="headerlink" title="● A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？"></a>● A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？</h2><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、程序内存管理：</p><p>一个程序本质上都是由BSS段、data段、text段三个组成的。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。</p><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470750551_BF3BB3BB445EFF96BEAE1410CE2CDA74" alt="img"></p><p>BSS段（未初始化数据区）：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。</p><p>数据段：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配</p><p>代码段：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量</p><p>text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。</p><p>bss段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。</p><p>data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中。</p><p>数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。包含数据段和BSS段的整个区段此时通常称为数据区。</p><p>可执行程序在运行时又多出两个区域：栈区和堆区。</p><p>栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</p><p>堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的 malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</p><p>2、A* a = new A; a-&gt;i = 10：</p><p>1）A *a：a是一个局部变量，类型为指针，故而操作系统在程序栈区开辟4/8字节的空间（0x000m），分配给指针a。</p><p>2）new A：通过new动态的在堆区申请类A大小的空间（0x000n）。</p><p>3）a = new A：将指针a的内存区域填入栈中类A申请到的地址的地址。即*（0x000m）=0x000n。</p><p>4）a-&gt;i：先找到指针a的地址0x000m，通过a的值0x000n和i在类a中偏移offset，得到a-&gt;i的地址0x000n + offset，进行*(0x000n + offset) = 10的赋值操作，即内存0x000n + offset的值是10。</p><h2 id="●-给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布"><a href="#●-给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布" class="headerlink" title="● 给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布"></a>● 给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布</h2><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、static修饰符</p><p>1）static修饰成员变量</p><p>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当做是类的成员，无论这个类被定义了多少个，静态数据成员都只有一份拷贝，为该类型的所有对象所共享(包括其派生类)。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。</p><p>因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。</p><p>2）static修饰成员函数</p><p>与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。</p><p>Static修饰的成员函数，在代码区分配内存。</p><p>2、C++继承和虚函数</p><p>C++多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。</p><p>动态多态实现有几个条件：</p><p>(1) 虚函数；</p><p>(2) 一个基类的指针或引用指向派生类的对象；</p><p>基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。</p><p>每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。</p><p>虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。</p><p>3、virtual修饰符</p><p>如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。</p><p>如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。</p><p>如果类中成员是virtual属性，会隐藏父类对应的属性。</p><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470920741_7D40CEF3951A10F626301148E06D89DA" alt="img"></p><h2 id="●-请你回答一下软链接和硬链接区别"><a href="#●-请你回答一下软链接和硬链接区别" class="headerlink" title="● 请你回答一下软链接和硬链接区别"></a>● 请你回答一下软链接和硬链接区别</h2><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>为了解决文件共享问题，Linux引入了软链接和硬链接。除了为Linux解决文件共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。若1个inode号对应多个文件名，则为硬链接，即硬链接就是同一个文件使用了不同的别名,使用ln创建。若文件用户数据块中存放的内容是另一个文件的路径名指向，则该文件是软连接。软连接是一个普通文件，有自己独立的inode,但是其数据块内容比较特殊。</p><h2 id="●-请问什么是大端小端以及如何判断大端小端"><a href="#●-请问什么是大端小端以及如何判断大端小端" class="headerlink" title="● 请问什么是大端小端以及如何判断大端小端"></a>● 请问什么是大端小端以及如何判断大端小端</h2><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>大端是指低字节存储在高地址；小端存储是指低字节存储在低地址。我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。</p><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470995798_E694EFF3D7CC8BA2BB2EE978CE1EB6FB" alt="img"></p><h2 id="●-请你回答一下静态变量什么时候初始化"><a href="#●-请你回答一下静态变量什么时候初始化" class="headerlink" title="● 请你回答一下静态变量什么时候初始化"></a>● 请你回答一下静态变量什么时候初始化</h2><h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>静态变量存储在虚拟地址空间的数据段和bss段，C语言中其在代码执行之前初始化，属于编译期初始化。而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造</p><h2 id="●-请你说一说用户态和内核态区别"><a href="#●-请你说一说用户态和内核态区别" class="headerlink" title="● 请你说一说用户态和内核态区别"></a>● 请你说一说用户态和内核态区别</h2><h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。</p><h2 id="●-如何设计server，使得能够接收多个客户端的请求"><a href="#●-如何设计server，使得能够接收多个客户端的请求" class="headerlink" title="● 如何设计server，使得能够接收多个客户端的请求"></a>● 如何设计server，使得能够接收多个客户端的请求</h2><h3 id="参考回答：-9"><a href="#参考回答：-9" class="headerlink" title="参考回答："></a>参考回答：</h3><p>多线程，线程池，io复用</p><h2 id="●-死循环-来连接时新建线程的方法效率有点低，怎么改进？"><a href="#●-死循环-来连接时新建线程的方法效率有点低，怎么改进？" class="headerlink" title="● 死循环+来连接时新建线程的方法效率有点低，怎么改进？"></a>● 死循环+来连接时新建线程的方法效率有点低，怎么改进？</h2><h3 id="参考回答：-10"><a href="#参考回答：-10" class="headerlink" title="参考回答："></a>参考回答：</h3><p>提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。改进死循环：使用select epoll这样的技术</p><h2 id="●-怎么唤醒被阻塞的socket线程？"><a href="#●-怎么唤醒被阻塞的socket线程？" class="headerlink" title="● 怎么唤醒被阻塞的socket线程？"></a>● 怎么唤醒被阻塞的socket线程？</h2><h3 id="参考回答：-11"><a href="#参考回答：-11" class="headerlink" title="参考回答："></a>参考回答：</h3><p>给阻塞时候缺少的资源</p><h2 id="●-怎样确定当前线程是繁忙还是阻塞？"><a href="#●-怎样确定当前线程是繁忙还是阻塞？" class="headerlink" title="● 怎样确定当前线程是繁忙还是阻塞？"></a>● 怎样确定当前线程是繁忙还是阻塞？</h2><h3 id="参考回答：-12"><a href="#参考回答：-12" class="headerlink" title="参考回答："></a>参考回答：</h3><p>使用ps命令查看</p><h2 id="●-请问就绪状态的进程在等待什么？"><a href="#●-请问就绪状态的进程在等待什么？" class="headerlink" title="● 请问就绪状态的进程在等待什么？"></a>● 请问就绪状态的进程在等待什么？</h2><h3 id="参考回答：-13"><a href="#参考回答：-13" class="headerlink" title="参考回答："></a>参考回答：</h3><p>被调度使用cpu的运行权</p><h2 id="●-请你说一说多线程的同步，锁的机制"><a href="#●-请你说一说多线程的同步，锁的机制" class="headerlink" title="● 请你说一说多线程的同步，锁的机制"></a>● 请你说一说多线程的同步，锁的机制</h2><h3 id="参考回答：-14"><a href="#参考回答：-14" class="headerlink" title="参考回答："></a>参考回答：</h3><p>同步的时候用一个互斥量，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁。如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥量加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行</p><h2 id="●-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"><a href="#●-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？" class="headerlink" title="● 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"></a>● 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</h2><h3 id="参考回答：-15"><a href="#参考回答：-15" class="headerlink" title="参考回答："></a>参考回答：</h3><p>单核cpu，并且开了抢占可以造成这种情况。</p><h2 id="●-windows消息机制知道吗，请说一说"><a href="#●-windows消息机制知道吗，请说一说" class="headerlink" title="● windows消息机制知道吗，请说一说"></a>● windows消息机制知道吗，请说一说</h2><h3 id="参考回答：-16"><a href="#参考回答：-16" class="headerlink" title="参考回答："></a>参考回答：</h3><p>当用户有操作(鼠标，键盘等)时，系统会将这些时间转化为消息。每个打开的进程系统都为其维护了一个消息队列，系统会将这些消息放到进程的消息队列中，而应用程序会循环从消息队列中取出来消息，完成对应的操作。</p><h2 id="●-C-的锁你知道几种"><a href="#●-C-的锁你知道几种" class="headerlink" title="● C++的锁你知道几种?"></a>● C++的锁你知道几种?</h2><h3 id="参考回答：-17"><a href="#参考回答：-17" class="headerlink" title="参考回答："></a>参考回答：</h3><p>锁包括互斥锁，条件变量，自旋锁和读写锁</p><h2 id="●-说一说你用到的锁"><a href="#●-说一说你用到的锁" class="headerlink" title="● 说一说你用到的锁"></a>● 说一说你用到的锁</h2><h3 id="参考回答：-18"><a href="#参考回答：-18" class="headerlink" title="参考回答："></a>参考回答：</h3><p>生产者消费者问题利用互斥锁和条件变量可以很容易解决，条件变量这里起到了替代信号量的作用</p><h2 id="●-请你说一说死锁产生的必要条件？"><a href="#●-请你说一说死锁产生的必要条件？" class="headerlink" title="● 请你说一说死锁产生的必要条件？"></a>● 请你说一说死锁产生的必要条件？</h2><h3 id="参考回答：-19"><a href="#参考回答：-19" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1.互斥条件：一个资源每次只能被一个进程使用。</p><h2 id="●-请你说一说什么是线程和进程，多线程和多进程通信方式"><a href="#●-请你说一说什么是线程和进程，多线程和多进程通信方式" class="headerlink" title="● 请你说一说什么是线程和进程，多线程和多进程通信方式"></a>● 请你说一说什么是线程和进程，多线程和多进程通信方式</h2><h3 id="参考回答：-20"><a href="#参考回答：-20" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）概念：</p><p>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</p><p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p><p>2）进程间通信的方式:</p><p>进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。</p><p>1、管道：</p><p>管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</p><p>普通管道PIPE：</p><p>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端</p><p>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</p><p>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p><p>命名管道FIFO：</p><p>FIFO可以在无关的进程之间交换数据</p><p>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p><p>2、消息队列</p><p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。具有写权限得进程可以按照一定得规则向消息队列中添加新信息，对消息队列有读权限得进程则可以从消息队列中读取信息。消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p><p>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p><p>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取，也可以按消息的类型读取。</p><p>3、信号量semaphore</p><p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用    来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于    存储进程间通信数据。</p><p>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</p><p>信号量基于操作系统的PV 操作，程序对信号量的操作都是原子操作。</p><p>每次对信号量的PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任    意正整数。</p><p>支持信号量组。</p><p>4信号signal</p><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p>5共享内存（Shared Memory）</p><p>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</p><p>共享内存是最快的一种IPC，因为进程是直接对内存进行存取</p><p>因为多个进程可以同时操作，所以需要进行同步</p><p>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</p><p>6、套接字SOCKET：</p><p>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</p><p>3）线程间通信的方式:</p><p>1、临界区：</p><p>通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p><p>2、互斥量 Synchronized/Lock：</p><p>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p><p>3、信号量 Semphare：</p><p>为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p><p>4、事件(信号)，Wait/Notify：</p><p>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p><h2 id="●-请你说一说内存溢出和内存泄漏"><a href="#●-请你说一说内存溢出和内存泄漏" class="headerlink" title="● 请你说一说内存溢出和内存泄漏"></a>● 请你说一说内存溢出和内存泄漏</h2><h3 id="参考回答：-21"><a href="#参考回答：-21" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、内存溢出</p><p>指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误</p><p>内存溢出原因：</p><p>内存中加载的数据量过于庞大，如一次从数据库取出过多数据</p><p>集合类中有对对象的引用，使用完后未清空，使得不能回收</p><p>代码中存在死循环或循环产生过多重复的对象实体</p><p>使用的第三方软件中的BUG</p><p>启动参数内存值设定的过小</p><p>2、内存泄漏</p><p>内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p><p>内存泄漏的分类：</p><p>1、堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。</p><p>2、系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</p><p>3、没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</p><h2 id="●-进程和线程的区别，你都使用什么线程模型"><a href="#●-进程和线程的区别，你都使用什么线程模型" class="headerlink" title="● 进程和线程的区别，你都使用什么线程模型"></a>● 进程和线程的区别，你都使用什么线程模型</h2><h3 id="参考回答：-22"><a href="#参考回答：-22" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）进程和线程区别</p><p>1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p><p>2、进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p><p>3、进程是资源分配的最小单位，线程是CPU调度的最小单位。</p><p>4、系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p><p>5、通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 。</p><p>6、进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p><p>7、进程间不会相互影响；线程一个线程挂掉将导致整个进程挂掉。</p><p>8、进程适应于多核、多机分布；线程适用于多核。</p><p>2、常用线程模型</p><p>1、Future模型</p><p>该模型通常在使用的时候需要结合Callable接口配合使用。</p><p>Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。</p><p>Callable是类似于Runnable的接口，其中call方法类似于run方法，所不同的是run方法不能抛出受检异常没有返回值，而call方法则可以抛出受检异常并可设置返回值。两者的方法体都是线程执行体。</p><p>2、fork&amp;join模型</p><p>该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。</p><p>这里模拟一个摘苹果的场景：有100棵苹果树，每棵苹果树有10个苹果，现在要把他们摘下来。为了节约时间，规定每个线程最多只能摘10棵苹树以便于节约时间。各个线程摘完之后汇总计算总苹果树。</p><p>3、actor模型</p><p>actor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。在使用actor模型的时候需要使用第三方Akka提供的框架。</p><p>4、生产者消费者模型</p><p>生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题。</p><p>5、master-worker模型</p><p>master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%861/"/>
    <url>/2021/07/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%861/</url>
    
    <content type="html"><![CDATA[<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的"><a href="#请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的" class="headerlink" title="请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的"></a>请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>基本概念：</p><p>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</p><p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p><p>区别：</p><p>1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p><p>2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p><p>3.进程是资源分配的最小单位，线程是CPU调度的最小单位；</p><p>4.系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p><p>5.通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预</p><p>6.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p><p>7.进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉</p><p>8.进程适应于多核、多机分布；线程适用于多核</p><p>进程间通信的方式：</p><p>进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。</p><p>1.管道：</p><p>管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</p><p>1.1 普通管道PIPE：</p><p>1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端</p><p>2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</p><p>3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p><p>1.2 命名管道FIFO：</p><p>1)FIFO可以在无关的进程之间交换数据</p><p>2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p><p>\2. 系统IPC：</p><p>2.1 消息队列</p><p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p><p>特点：</p><p>1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p><p>2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p><p>3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p><p>2.2 信号量semaphore</p><p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p><p>特点：</p><p>1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</p><p>2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</p><p>3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p><p>4)支持信号量组。</p><p>2.3 信号signal</p><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p>2.4 共享内存（Shared Memory）</p><p>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等</p><p>特点：</p><p>1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取</p><p>2)因为多个进程可以同时操作，所以需要进行同步</p><p>3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</p><p>3.套接字SOCKET：</p><p>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</p><p>线程间通信的方式:</p><p>临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p><p>互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p><p>信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p><p>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p><h2 id="●-请你说一说Linux虚拟地址空间"><a href="#●-请你说一说Linux虚拟地址空间" class="headerlink" title="● 请你说一说Linux虚拟地址空间"></a>● 请你说一说Linux虚拟地址空间</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p>为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存。</p><p>虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p><p>请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</p><p>虚拟内存的好处：</p><p>1.扩大地址空间；</p><p>2.内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。</p><p>3.公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。</p><p>4.当进程通信时，可采用虚存共享的方式实现。</p><p>5.当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存</p><p>6.虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高</p><p>7.在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片</p><p>虚拟内存的代价：</p><p>1.虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存</p><p>2.虚拟地址到物理地址的转换，增加了指令的执行时间。</p><p>3.页面的换入换出需要磁盘I/O，这是很耗时的</p><p>4.如果一页中只有一部分数据，会浪费内存。</p><h2 id="●-请你说一说操作系统中的程序的内存结构"><a href="#●-请你说一说操作系统中的程序的内存结构" class="headerlink" title="● 请你说一说操作系统中的程序的内存结构"></a>● 请你说一说操作系统中的程序的内存结构</h2><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552469062814_B7994596FDDB98A22E80E1D2556A6153" alt="img"></p><h2 id="●-请你说一说操作系统中的缺页中断"><a href="#●-请你说一说操作系统中的缺页中断" class="headerlink" title="● 请你说一说操作系统中的缺页中断"></a>● 请你说一说操作系统中的缺页中断</h2><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p>malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。</p><p>缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</p><p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p><p>1、保护CPU现场</p><p>2、分析中断原因</p><p>3、转入缺页中断处理程序进行处理</p><p>4、恢复CPU现场，继续执行</p><p>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：</p><p>1、在指令执行期间产生和处理缺页中断信号</p><p>2、一条指令在执行期间，可能产生多次缺页中断</p><p>3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。</p><h2 id="●-请你回答一下fork和vfork的区别"><a href="#●-请你回答一下fork和vfork的区别" class="headerlink" title="● 请你回答一下fork和vfork的区别"></a>● 请你回答一下fork和vfork的区别</h2><h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="参考回答："></a>参考回答：</h3><p>fork的基础知识：</p><p>fork:创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p><p>#include &lt;sys/types.h&gt;</p><p>#include &lt;unistd.h&gt;</p><p>pid_t fork(void);</p><p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p><p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p><p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p><p>vfork的基础知识：</p><p>在实现写时复制之前，Unix的设计者们就一直很关注在fork后立刻执行exec所造成的地址空间的浪费。BSD的开发者们在3.0的BSD系统中引入了vfork( )系统调用。</p><p>#include &lt;sys/types.h&gt;</p><p>#include &lt;unistd.h&gt;</p><p>pid_t vfork(void);</p><p>除了子进程必须要立刻执行一次对exec的系统调用，或者调用_exit( )退出，对vfork( )的成功调用所产生的结果和fork( )是一样的。vfork( )会挂起父进程直到子进程终止或者运行了一个新的可执行文件的映像。通过这样的方式，vfork( )避免了地址空间的按页复制。在这个过程中，父进程和子进程共享相同的地址空间和页表项。实际上vfork( )只完成了一件事：复制内部的内核数据结构。因此，子进程也就不能修改地址空间中的任何内存。</p><p>vfork( )是一个历史遗留产物，Linux本不应该实现它。需要注意的是，即使增加了写时复制，vfork( )也要比fork( )快，因为它没有进行页表项的复制。然而，写时复制的出现减少了对于替换fork( )争论。实际上，直到2.2.0内核，vfork( )只是一个封装过的fork( )。因为对vfork( )的需求要小于fork( )，所以vfork( )的这种实现方式是可行的。</p><p>补充知识点：写时复制</p><p>Linux采用了写时复制的方法，以减少fork时对父进程空间进程整体复制带来的开销。</p><p>写时复制是一种采取了惰性优化方法来避免复制时的系统开销。它的前提很简单：如果有多个进程要读取它们自己的那部门资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。只要没有进程要去修改自己的“副本”，就存在着这样的幻觉：每个进程好像独占那个资源。从而就避免了复制带来的负担。如果一个进程要修改自己的那份资源“副本”，那么就会复制那份资源，并把复制的那份提供给进程。不过其中的复制对进程来说是透明的。这个进程就可以修改复制后的资源了，同时其他的进程仍然共享那份没有修改过的资源。所以这就是名称的由来：在写入时进行复制。</p><p>写时复制的主要好处在于：如果进程从来就不需要修改资源，则不需要进行复制。惰性算法的好处就在于它们尽量推迟代价高昂的操作，直到必要的时刻才会去执行。</p><p>在使用虚拟内存的情况下，写时复制（Copy-On-Write）是以页为基础进行的。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。在fork( )调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。</p><p>写时复制在内核中的实现非常简单。与内核页相关的数据结构可以被标记为只读和写时复制。如果有进程试图修改一个页，就会产生一个缺页中断。内核处理缺页中断的方式就是对该页进行一次透明复制。这时会清除页面的COW属性，表示着它不再被共享。</p><p>现代的计算机系统结构中都在内存管理单元（MMU）提供了硬件级别的写时复制支持，所以实现是很容易的。</p><p>在调用fork( )时，写时复制是有很大优势的。因为大量的fork之后都会跟着执行exec，那么复制整个父进程地址空间中的内容到子进程的地址空间完全是在浪费时间：如果子进程立刻执行一个新的二进制可执行文件的映像，它先前的地址空间就会被交换出去。写时复制可以对这种情况进行优化。</p><p>fork和vfork的区别：</p><p>\1. fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段</p><p>\2. fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。</p><p>\3. vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</p><p>4.当需要改变共享数据段中变量的值，则拷贝父进程。</p><h2 id="●-请问如何修改文件最大句柄数？"><a href="#●-请问如何修改文件最大句柄数？" class="headerlink" title="● 请问如何修改文件最大句柄数？"></a>● 请问如何修改文件最大句柄数？</h2><h3 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h3><p>linux默认最大文件句柄数是1024个，在linux服务器文件并发量比较大的情况下，系统会报”too many open files”的错误。故在linux服务器高并发调优时，往往需要预先调优Linux参数，修改Linux最大文件句柄数。</p><p>有两种方法：</p><p>\1. ulimit -n &lt;可以同时打开的文件数&gt;，将当前进程的最大句柄数修改为指定的参数（注：该方法只针对当前进程有效，重新打开一个shell或者重新开启一个进程，参数还是之前的值）</p><p>首先用ulimit -a查询Linux相关的参数，如下所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">core</span> <span class="hljs-selector-tag">file</span> <span class="hljs-selector-tag">size</span>          (blocks, -c) <span class="hljs-selector-tag">0</span><br><span class="hljs-selector-tag">data</span> <span class="hljs-selector-tag">seg</span> <span class="hljs-selector-tag">size</span>           (kbytes, -d) <span class="hljs-selector-tag">unlimited</span><br><span class="hljs-selector-tag">scheduling</span> <span class="hljs-selector-tag">priority</span>             (-e) <span class="hljs-selector-tag">0</span><br><span class="hljs-selector-tag">file</span> <span class="hljs-selector-tag">size</span>               (blocks, -f) <span class="hljs-selector-tag">unlimited</span><br><span class="hljs-selector-tag">pending</span> <span class="hljs-selector-tag">signals</span>                 (-i) <span class="hljs-selector-tag">94739</span><br><span class="hljs-selector-tag">max</span> <span class="hljs-selector-tag">locked</span> <span class="hljs-selector-tag">memory</span>       (kbytes, -l) <span class="hljs-selector-tag">64</span><br><span class="hljs-selector-tag">max</span> <span class="hljs-selector-tag">memory</span> <span class="hljs-selector-tag">size</span>         (kbytes, -m) <span class="hljs-selector-tag">unlimited</span><br><span class="hljs-selector-tag">open</span> <span class="hljs-selector-tag">files</span>                      (-n) <span class="hljs-selector-tag">1024</span><br><span class="hljs-selector-tag">pipe</span> <span class="hljs-selector-tag">size</span>            (<span class="hljs-number">512</span> bytes, -p) <span class="hljs-selector-tag">8</span><br><span class="hljs-selector-tag">POSIX</span> <span class="hljs-selector-tag">message</span> <span class="hljs-selector-tag">queues</span>     (bytes, -q) <span class="hljs-selector-tag">819200</span><br><span class="hljs-selector-tag">real-time</span> <span class="hljs-selector-tag">priority</span>              (-r) <span class="hljs-selector-tag">0</span><br><span class="hljs-selector-tag">stack</span> <span class="hljs-selector-tag">size</span>              (kbytes, -s) <span class="hljs-selector-tag">8192</span><br><span class="hljs-selector-tag">cpu</span> <span class="hljs-selector-tag">time</span>               (seconds, -t) <span class="hljs-selector-tag">unlimited</span><br><span class="hljs-selector-tag">max</span> <span class="hljs-selector-tag">user</span> <span class="hljs-selector-tag">processes</span>              (-u) <span class="hljs-selector-tag">94739</span><br><span class="hljs-selector-tag">virtual</span> <span class="hljs-selector-tag">memory</span>          (kbytes, -v) <span class="hljs-selector-tag">unlimited</span><br><span class="hljs-selector-tag">file</span> <span class="hljs-selector-tag">locks</span>                      (-x) <span class="hljs-selector-tag">unlimited</span><br></code></pre></td></tr></table></figure><p>其中，open files就是最大文件句柄数，默认是1024个。</p><p>修改Linux最大文件句柄数：  ulimit -n 2048， 将最大句柄数修改为 2048个。</p><p>\2. 对所有进程都有效的方法，修改Linux系统参数</p><p>vi /etc/security/limits.conf 添加</p><p>*　　soft　　nofile　　65536</p><p>*　　hard　　nofile　　65536</p><p>将最大句柄数改为65536</p><p>修改以后保存，注销当前用户，重新登录，修改后的参数就生效了</p><h2 id="●-请你说一说并发-concurrency-和并行-parallelism"><a href="#●-请你说一说并发-concurrency-和并行-parallelism" class="headerlink" title="● 请你说一说并发(concurrency)和并行(parallelism)"></a>● 请你说一说并发(concurrency)和并行(parallelism)</h2><h3 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h3><p>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。</p><p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。</p><h2 id="●-请问MySQL的端口号是多少，如何修改这个端口号"><a href="#●-请问MySQL的端口号是多少，如何修改这个端口号" class="headerlink" title="● 请问MySQL的端口号是多少，如何修改这个端口号"></a>● 请问MySQL的端口号是多少，如何修改这个端口号</h2><h3 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h3><p>查看端口号：</p><p>使用命令show global variables like ‘port’;查看端口号 ，mysql的默认端口是3306。（补充：sqlserver默认端口号为：1433；oracle默认端口号为：1521；DB2默认端口号为：5000；PostgreSQL默认端口号为：5432）</p><p>修改端口号：</p><p>修改端口号：编辑/etc/my.cnf文件，早期版本有可能是my.conf文件名，增加端口参数，并且设定端口，注意该端口未被使用，保存退出。</p><h2 id="●-请你说一说操作系统中的页表寻址"><a href="#●-请你说一说操作系统中的页表寻址" class="headerlink" title="● 请你说一说操作系统中的页表寻址"></a>● 请你说一说操作系统中的页表寻址</h2><h3 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h3><p>页式内存管理，内存分成固定长度的一个个页片。操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表，页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定。一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。</p><p>Linux最初的两级页表机制：</p><p>两级分页机制将32位的虚拟空间分成三段，低十二位表示页内偏移，高20分成两段分别表示两级页表的偏移。</p><p>* PGD(Page Global Directory): 最高10位，全局页目录表索引</p><p>* PTE(Page Table Entry)：中间10位，页表入口索引</p><p>当在进行地址转换时，结合在CR3寄存器中存放的页目录(page directory, PGD)的这一页的物理地址，再加上从虚拟地址中抽出高10位叫做页目录表项(内核也称这为pgd)的部分作为偏移, 即定位到可以描述该地址的pgd；从该pgd中可以获取可以描述该地址的页表的物理地址，再加上从虚拟地址中抽取中间10位作为偏移, 即定位到可以描述该地址的pte；在这个pte中即可获取该地址对应的页的物理地址, 加上从虚拟地址中抽取的最后12位，即形成该页的页内偏移, 即可最终完成从虚拟地址到物理地址的转换。从上述过程中，可以看出，对虚拟地址的分级解析过程，实际上就是不断深入页表层次，逐渐定位到最终地址的过程，所以这一过程被叫做page talbe walk。</p><p>Linux的三级页表机制：</p><p>当X86引入物理地址扩展(Pisycal Addrress Extension, PAE)后，可以支持大于4G的物理内存(36位），但虚拟地址依然是32位，原先的页表项不适用，它实际多4 bytes被扩充到8 bytes，这意味着，每一页现在能存放的pte数目从1024变成512了(4k/8)。相应地，页表层级发生了变化，Linus新增加了一个层级，叫做页中间目录(page middle directory, PMD), 变成：</p><p>字段            描述                        位数</p><p>cr3            指向一个PDPT            crs寄存器存储</p><p>PGD        指向PDPT中4个项中的一个    位31~30</p><p>PMD        指向页目录中512项中的一个    位29~21</p><p>PTE            指向页表中512项中的一个    位20~12</p><p>page offset    4KB页中的偏移            位11~0</p><p>现在就同时存在2级页表和3级页表，在代码管理上肯定不方便。巧妙的是，Linux采取了一种抽象方法：所有架构全部使用3级页表: 即PGD -&gt; PMD -&gt; PTE。那只使用2级页表(如非PAE的X86)怎么办？</p><p>办法是针对使用2级页表的架构，把PMD抽象掉，即虚设一个PMD表项。这样在page table walk过程中，PGD本直接指向PTE的，现在不了，指向一个虚拟的PMD，然后再由PMD指向PTE。这种抽象保持了代码结构的统一。</p><p>Linux的四级页表机制：</p><p>硬件在发展，3级页表很快又捉襟见肘了，原因是64位CPU出现了, 比如X86_64， 它的硬件是实实在在支持4级页表的。它支持48位的虚拟地址空间1。如下：</p><p>字段            描述                        位数</p><p>PML4        指向一个PDPT            位47~39</p><p>PGD        指向PDPT中4个项中的一个    位38~30</p><p>PMD        指向页目录中512项中的一个    位29~21</p><p>PTE            指向页表中512项中的一个    位20~12</p><p>page offset    4KB页中的偏移            位11~0</p><p>Linux内核针为使用原来的3级列表(PGD-&gt;PMD-&gt;PTE)，做了折衷。即采用一个唯一的，共享的顶级层次，叫PML4。这个PML4没有编码在地址中，这样就能套用原来的3级列表方案了。不过代价就是，由于只有唯一的PML4, 寻址空间被局限在(239=)512G, 而本来PML4段有9位, 可以支持512个PML4表项的。现在为了使用3级列表方案，只能限制使用一个， 512G的空间很快就又不够用了，解决方案呼之欲出。</p><p>在2004年10月，当时的X86_64架构代码的维护者Andi Kleen提交了一个叫做4level page tables for Linux的PATCH系列，为Linux内核带来了4级页表的支持。在他的解决方案中，不出意料地，按照X86_64规范，新增了一个PML4的层级, 在这种解决方案中，X86_64拥一个有512条目的PML4, 512条目的PGD, 512条目的PMD, 512条目的PTE。对于仍使用3级目录的架构来说，它们依然拥有一个虚拟的PML4,相关的代码会在编译时被优化掉。 这样，就把Linux内核的3级列表扩充为4级列表。这系列PATCH工作得不错，不久被纳入Andrew Morton的-mm树接受测试。不出意外的话，它将在v2.6.11版本中释出。但是，另一个知名开发者Nick Piggin提出了一些看法，他认为Andi的Patch很不错，不过他认为最好还是把PGD作为第一级目录，把新增加的层次放在中间，并给出了他自己的Patch:alternate 4-level page tables patches。Andi更想保持自己的PATCH, 他认为Nick不过是玩了改名的游戏，而且他的PATCH经过测试很稳定，快被合并到主线了，不宜再折腾。不过Linus却表达了对Nick Piggin的支持，理由是Nick的做法conceptually least intrusive。毕竟作为Linux的扛把子，稳定对于Linus来说意义重大。最终，不意外地，最后Nick Piggin的PATCH在v2.6.11版本中被合并入主线。在这种方案中，4级页表分别是：PGD -&gt; PUD -&gt; PMD -&gt; PTE。</p><h2 id="●-请你说一说有了进程，为什么还要有线程？"><a href="#●-请你说一说有了进程，为什么还要有线程？" class="headerlink" title="● 请你说一说有了进程，为什么还要有线程？"></a>● 请你说一说有了进程，为什么还要有线程？</h2><h3 id="参考回答：-9"><a href="#参考回答：-9" class="headerlink" title="参考回答："></a>参考回答：</h3><p>线程产生的原因：</p><p>进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：</p><p>进程在同一时间只能干一件事</p><p>进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。</p><p>因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。和进程相比，线程的优势如下：</p><p>从资源上来讲，线程是一种非常”节俭”的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。</p><p>从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。（</p><p>从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。</p><p>除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：</p><p>1、使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</p><p>2、改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。</p><h2 id="●-请问单核机器上写多线程程序，是否需要考虑加锁，为什么？"><a href="#●-请问单核机器上写多线程程序，是否需要考虑加锁，为什么？" class="headerlink" title="● 请问单核机器上写多线程程序，是否需要考虑加锁，为什么？"></a>● 请问单核机器上写多线程程序，是否需要考虑加锁，为什么？</h2><h3 id="参考回答：-10"><a href="#参考回答：-10" class="headerlink" title="参考回答："></a>参考回答：</h3><p>在单核机器上写多线程程序，仍然需要线程锁。因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突。</p><h2 id="●-请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"><a href="#●-请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的" class="headerlink" title="● 请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"></a>● 请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的</h2><h3 id="参考回答：-11"><a href="#参考回答：-11" class="headerlink" title="参考回答："></a>参考回答：</h3><p>线程在切换的过程中需要保存当前线程Id、线程状态、堆栈、寄存器状态等信息。其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：</p><p>SP:堆栈指针，指向当前栈的栈顶地址</p><p>PC:程序计数器，存储下一条将要执行的指令</p><p>EAX:累加寄存器，用于加法乘法的缺省寄存器</p><h2 id="●-请你说一说线程间的同步方式，最好说出具体的系统调用"><a href="#●-请你说一说线程间的同步方式，最好说出具体的系统调用" class="headerlink" title="● 请你说一说线程间的同步方式，最好说出具体的系统调用"></a>● 请你说一说线程间的同步方式，最好说出具体的系统调用</h2><h3 id="参考回答：-12"><a href="#参考回答：-12" class="headerlink" title="参考回答："></a>参考回答：</h3><p>信号量</p><p>信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：</p><p>P(SV):如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程。</p><p>V(SV)：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1。</p><p>其系统调用为：</p><p>sem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。</p><p>sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。</p><p>互斥量</p><p>互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区      时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：</p><p>pthread_mutex_init:初始化互斥锁</p><p>pthread_mutex_destroy：销毁互斥锁</p><p>pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。</p><p>pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁。</p><p>条件变量</p><p>条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用 signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：</p><p>pthread_cond_init:初始化条件变量</p><p>pthread_cond_destroy：销毁条件变量</p><p>pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。</p><p>pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。</p><h2 id="●-请你说一下多线程和多进程的不同"><a href="#●-请你说一下多线程和多进程的不同" class="headerlink" title="● 请你说一下多线程和多进程的不同"></a>● 请你说一下多线程和多进程的不同</h2><h3 id="参考回答：-13"><a href="#参考回答：-13" class="headerlink" title="参考回答："></a>参考回答：</h3><p>进程是资源分配的最小单位，而线程时CPU调度的最小单位。多线程之间共享同一个进程的地址空间，线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存少，适用于多核分布式系统，但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程也终止，程序可靠性弱。而多进程间拥有各自独立的运行地址空间，进程间不会相互影响，程序可靠性强，但是进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单，适用于多核、多机分布。</p><h2 id="●-请你说一说进程和线程的区别"><a href="#●-请你说一说进程和线程的区别" class="headerlink" title="● 请你说一说进程和线程的区别"></a>● 请你说一说进程和线程的区别</h2><h3 id="参考回答：-14"><a href="#参考回答：-14" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。</p><p>2）进程有独立的系统资源，而同一进程内的线程共享进程的大部分系统资源,包括堆、代码段、数据段，每个线程只拥有一些在运行中必不可少的私有属性，比如tcb,线程Id,栈、寄存器。</p><p>3）一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也死掉。</p><p>4）进程在创建、切换和销毁时开销比较大，而线程比较小。进程创建的时候需要分配系统资源，而销毁的的时候需要释放系统资源。进程切换需要分两步：切换页目录、刷新TLB以使用新的地址空间；切换内核栈和硬件上下文（寄存器）；而同一进程的线程间逻辑地址空间是一样的，不需要切换页目录、刷新TLB。</p><p>5）进程间通信比较复杂，而同一进程的线程由于共享代码段和数据段，所以通信比较容易。</p><h2 id="●-游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？"><a href="#●-游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？" class="headerlink" title="● 游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？"></a>● 游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？</h2><h3 id="参考回答：-15"><a href="#参考回答：-15" class="headerlink" title="参考回答："></a>参考回答：</h3><p>游戏服务器应该为每个用户开辟一个进程。因为同一进程间的线程会相互影响，一个线程死掉会影响其他线程，从而导致进程崩溃。因此为了保证不同用户之间不会相互影响，应该为每个用户开辟一个进程</p><h2 id="●-请你说一说OS缺页置换算法"><a href="#●-请你说一说OS缺页置换算法" class="headerlink" title="● 请你说一说OS缺页置换算法"></a>● 请你说一说OS缺页置换算法</h2><h3 id="参考回答：-16"><a href="#参考回答：-16" class="headerlink" title="参考回答："></a>参考回答：</h3><p>当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：</p><p>先进先出(FIFO)算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。</p><p>最近最少使用（LRU）算法: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。</p><p>当前最常采用的就是LRU算法。</p><h2 id="●-请你说一说进程和线程区别"><a href="#●-请你说一说进程和线程区别" class="headerlink" title="● 请你说一说进程和线程区别"></a>● 请你说一说进程和线程区别</h2><h3 id="参考回答：-17"><a href="#参考回答：-17" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1）进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。</p><p>2）进程有独立的系统资源，而同一进程内的线程共享进程的大部分系统资源,包括堆、代码段、数据段，每个线程只拥有一些在运行中必不可少的私有属性，比如tcb,线程Id,栈、寄存器。</p><p>3）一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也死掉。</p><p>4）进程在创建、切换和销毁时开销比较大，而线程比较小。进程创建的时候需要分配系统资源，而销毁的的时候需要释放系统资源。进程切换需要分两步：切换页目录、刷新TLB以使用新的地址空间；切换内核栈和硬件上下文（寄存器）；而同一进程的线程间逻辑地址空间是一样的，不需要切换页目录、刷新TLB。</p><p>5）进程间通信比较复杂，而同一进程的线程由于共享代码段和数据段，所以通信比较容易。</p><h2 id="●-请你说一下多进程和多线程的使用场景"><a href="#●-请你说一下多进程和多线程的使用场景" class="headerlink" title="● 请你说一下多进程和多线程的使用场景"></a>● 请你说一下多进程和多线程的使用场景</h2><h3 id="参考回答：-18"><a href="#参考回答：-18" class="headerlink" title="参考回答："></a>参考回答：</h3><p>多进程模型的优势是CPU</p><p>多线程模型主要优势为线程间切换代价较小，因此适用于I/O密集型的工作场景，因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁的切换线程。同时，多线程模型也适用于单机多核分布式场景。</p><p>多进程模型，适用于CPU密集型。同时，多进程模型也适用于多机分布式场景中，易于多机扩展。</p><h2 id="●-请你说一说死锁发生的条件以及如何解决死锁"><a href="#●-请你说一说死锁发生的条件以及如何解决死锁" class="headerlink" title="● 请你说一说死锁发生的条件以及如何解决死锁"></a>● 请你说一说死锁发生的条件以及如何解决死锁</h2><h3 id="参考回答：-19"><a href="#参考回答：-19" class="headerlink" title="参考回答："></a>参考回答：</h3><p>死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下：</p><p>互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；</p><p>请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源</p><p>不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</p><p>环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链</p><p>解决死锁的方法即破坏上述四个条件之一，主要方法如下：</p><p>资源一次性分配，从而剥夺请求和保持条件</p><p>可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件</p><p>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件</p><h2 id="●-请问虚拟内存和物理内存怎么对应"><a href="#●-请问虚拟内存和物理内存怎么对应" class="headerlink" title="● 请问虚拟内存和物理内存怎么对应"></a>● 请问虚拟内存和物理内存怎么对应</h2><h3 id="参考回答：-20"><a href="#参考回答：-20" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、概念：</p><p>物理地址(physical address)</p><p>用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。</p><p>虽然可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽像，内存的寻址方式并不是这样。所以，说它是“与地址总线相对应”，是更贴切一些，不过抛开对物理内存寻址方式的考虑，直接把物理地址与物理的内存一一对应，也是可以接受的。也许错误的理解更利于形而上的抽像。</p><p>虚拟地址(virtual memory)</p><p>这是对整个内存（不要与机器上插那条对上号）的抽像描述。它是相对于物理内存来讲的，可以直接理解成“不直实的”，“假的”内存，例如，一个0x08000000内存地址，它并不对就物理地址上那个大数组中0x08000000 - 1那个地址元素；</p><p>之所以是这样，是因为现代操作系统都提供了一种内存管理的抽像，即虚拟内存（virtual memory）。进程使用虚拟内存中的地址，由操作系统协助相关硬件，把它“转换”成真正的物理地址。这个“转换”，是所有问题讨论的关键。</p><p>有了这样的抽像，一个程序，就可以使用比真实物理地址大得多的地址空间。甚至多个进程可以使用相同的地址。不奇怪，因为转换后的物理地址并非相同的。</p><p>——可以把连接后的程序反编译看一下，发现连接器已经为程序分配了一个地址，例如，要调用某个函数A，代码不是call A，而是call 0x0811111111 ，也就是说，函数A的地址已经被定下来了。没有这样的“转换”，没有虚拟地址的概念，这样做是根本行不通的。</p><p>2、地址转换</p><p>第一步：CPU段式管理中——逻辑地址转线性地址</p><p>CPU要利用其段式内存管理单元，先将为个逻辑地址转换成一个线程地址。</p><p>一个逻辑地址由两部份组成，【段标识符：段内偏移量】。</p><p>段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节，如图：</p><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470210037_13DB46E4DEE567FEF6756A26C5A0EC62" alt="img"></p><p>通过段标识符中的索引号从GDT或者LDT找到该段的段描述符，段描述符中的base字段是段的起始地址</p><p>段描述符：Base字段，它描述了一个段的开始位置的线性地址。</p><p>一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。</p><p>GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中。</p><p>段起始地址+ 段内偏移量 = 线性地址</p><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470239469_B327A1776BDD614C1FA189B123676D44" alt="img"></p><p>首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]，</p><p>1、看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。</p><p>2、拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，它了Base，即基地址就知道了。</p><p>3、把Base + offset，就是要转换的线性地址了。</p><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470270211_A8B080AAD8609459CD745F5E2480B919" alt="img"></p><p>第一步：页式管理——线性地址转物理地址</p><p>再利用其页式内存管理单元，转换为最终物理地址。</p><p>linux假的段式管理</p><p>Intel要求两次转换，这样虽说是兼容了，但是却是很冗余，但是这是intel硬件的要求。</p><p>其它某些硬件平台，没有二次转换的概念，Linux也需要提供一个高层抽像，来提供一个统一的界面。</p><p>所以，Linux的段式管理，事实上只是“哄骗”了一下硬件而已。</p><p>按照Intel的本意，全局的用GDT，每个进程自己的用LDT——不过Linux则对所有的进程都使用了相同的段来对指令和数据寻址。即用户数据段，用户代码段，对应的，内核中的是内核数据段和内核代码段。</p><p>在Linux下，逻辑地址与线性地址总是一致的，即逻辑地址的偏移量字段的值与线性地址的值总是相同的。</p><p>linux页式管理</p><p>CPU的页式内存管理单元，负责把一个线性地址，最终翻译为一个物理地址。</p><p>线性地址被分为以固定长度为单位的组，称为页(page)，例如一个32位的机器，线性地址最大可为4G，可以用4KB为一个页来划分，这页，整个线性地址就被划分为一个tatol_page[2^20]的大数组，共有2的20个次方个页。</p><p>另一类“页”，我们称之为物理页，或者是页框、页桢的。是分页单元把所有的物理内存也划分为固定长度的管理单位，它的长度一般与内存页是一一对应的。</p><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470300375_E395C4896EA5D7621E9211A0C3817BB5" alt="img"></p><p>每个进程都有自己的页目录，当进程处于运行态的时候，其页目录地址存放在cr3寄存器中。</p><p>每一个32位的线性地址被划分为三部份，【页目录索引(10位)：页表索引(10位)：页内偏移(12位)】</p><p>依据以下步骤进行转换：</p><p>从cr3中取出进程的页目录地址（操作系统负责在调度进程的时候，把这个地址装入对应寄存器）；</p><p>根据线性地址前十位，在数组中，找到对应的索引项，因为引入了二级管理模式，页目录中的项，不再是页的地址，而是一个页表的地址。（又引入了一个数组），页的地址被放到页表中去了。</p><p>根据线性地址的中间十位，在页表（也是数组）中找到页的起始地址；</p><p>将页的起始地址与线性地址中最后12位相加。</p><p>目的：</p><p>内存节约：如果一级页表中的一个页表条目为空，那么那所指的二级页表就根本不会存在。这表现出一种巨大的潜在节约，因为对于一个典型的程序，4GB虚拟地址空间的大部份都会是未分配的；</p><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470330729_28397F90C2D7C059A122BFF0B4DFD63A" alt="img"></p><p>32位，PGD = 10bit，PUD = PMD = 0，table = 10bit，offset = 12bit</p><p>64位，PUD和PMD ≠ 0</p><h2 id="●-请你说一说操作系统中的结构体对齐，字节对齐"><a href="#●-请你说一说操作系统中的结构体对齐，字节对齐" class="headerlink" title="● 请你说一说操作系统中的结构体对齐，字节对齐"></a>● 请你说一说操作系统中的结构体对齐，字节对齐</h2><h3 id="参考回答：-21"><a href="#参考回答：-21" class="headerlink" title="参考回答："></a>参考回答：</h3><p>1、原因：</p><p>1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p><p>2）性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p><p>2、规则</p><p>1）数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。</p><p>2）结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</p><p>3）结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。</p><p>3、定义结构体对齐</p><p>可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。</p><p>4、举例</p><p>#pragma pack(2)</p><p>struct AA {</p><p>int a;       //长度4 &gt; 2 按2对齐；偏移量为0；存放位置区间[0,3]</p><p>char b;  //长度1 &lt; 2 按1对齐；偏移量为4；存放位置区间[4]</p><p>short c;     //长度2 = 2 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</p><p>char d;  //长度1 &lt; 2 按1对齐；偏移量为7；存放位置区间[8]；共九个字节</p><p>};</p><p>#pragma pack()</p><h2 id="●-请问进程间怎么通信"><a href="#●-请问进程间怎么通信" class="headerlink" title="● 请问进程间怎么通信"></a>● 请问进程间怎么通信</h2><h3 id="参考回答：-22"><a href="#参考回答：-22" class="headerlink" title="参考回答："></a>参考回答：</h3><p>进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。</p><p>1.管道：</p><p>管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</p><p>1.1 普通管道PIPE：</p><p>1）它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端</p><p>2）它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</p><p>3）它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p><p>1.2 命名管道FIFO：</p><p>1）FIFO可以在无关的进程之间交换数据</p><p>2）FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p><p>\2. 系统IPC：</p><p>2.1 消息队列</p><p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p><p>特点：</p><p>1）消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p><p>2）消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p><p>3）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p><p>2.2 信号量semaphore</p><p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p><p>特点：</p><p>1）信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</p><p>2）信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</p><p>3）每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p><p>4）支持信号量组。</p><p>2.3 信号signal</p><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p>2.4 共享内存（Shared Memory）</p><p>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等</p><p>特点：</p><p>1）共享内存是最快的一种IPC，因为进程是直接对内存进行存取</p><p>2）因为多个进程可以同时操作，所以需要进行同步</p><p>3）信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</p><p>\3. 套接字SOCKET：</p><p>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</p><h2 id="●-请你说一下虚拟内存置换的方式"><a href="#●-请你说一下虚拟内存置换的方式" class="headerlink" title="● 请你说一下虚拟内存置换的方式"></a>● 请你说一下虚拟内存置换的方式</h2><h3 id="参考回答：-23"><a href="#参考回答：-23" class="headerlink" title="参考回答："></a>参考回答：</h3><p>比较常见的内存替换算法有：FIFO，LRU，LFU，LRU-K，2Q。</p><p>1、FIFO（先进先出淘汰算法）</p><p>思想：最近刚访问的，将来访问的可能性比较大。</p><p>实现：使用一个队列，新加入的页面放入队尾，每次淘汰队首的页面，即最先进入的数据，最先被淘汰。</p><p>弊端：无法体现页面冷热信息</p><p>2、LFU（最不经常访问淘汰算法）</p><p>思想：如果数据过去被访问多次，那么将来被访问的频率也更高。</p><p>实现：每个数据块一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。每次淘汰队尾数据块。</p><p>开销：排序开销。</p><p>弊端：缓存颠簸。</p><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470476683_909843CE326FD7243A252E09C80772B8" alt="img"></p><p>3、LRU（最近最少使用替换算法）</p><p>思想：如果数据最近被访问过，那么将来被访问的几率也更高。</p><p>实现：使用一个栈，新页面或者命中的页面则将该页面移动到栈底，每次替换栈顶的缓存页面。</p><p>优点：LRU算法对热点数据命中率是很高的。</p><p>缺陷：</p><p>1）缓存颠簸，当缓存（1，2，3）满了，之后数据访问（0，3，2，1，0，3，2，1。。。）。</p><p>2）缓存污染，突然大量偶发性的数据访问，会让内存中存放大量冷数据。</p><p>4、LRU-K（LRU-2、LRU-3）</p><p>思想：最久未使用K次淘汰算法。</p><p>LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p><p>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。</p><p>实现：</p><p>1）数据第一次被访问，加入到访问历史列表；</p><p>2）如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</p><p>3）当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</p><p>4）缓存数据队列中被再次访问后，重新排序；</p><p>5）需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</p><p>针对问题：</p><p>LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p><p>5、2Q</p><p>类似LRU-2。使用一个FIFO队列和一个LRU队列。</p><p>实现：</p><p>1）新访问的数据插入到FIFO队列；</p><p>2）如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</p><p>3）如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部；</p><p>4）如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；</p><p>5）LRU队列淘汰末尾的数据。</p><p>针对问题：LRU的缓存污染</p><p>弊端：</p><p>当FIFO容量为2时，访问负载是：ABCABCABC会退化为FIFO，用不到LRU。</p><h2 id="●-请你说一下多线程，线程同步的几种方式"><a href="#●-请你说一下多线程，线程同步的几种方式" class="headerlink" title="● 请你说一下多线程，线程同步的几种方式"></a>● 请你说一下多线程，线程同步的几种方式</h2><h3 id="参考回答：-24"><a href="#参考回答：-24" class="headerlink" title="参考回答："></a>参考回答：</h3><p>概念：</p><p>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</p><p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p><p>线程间通信的方式:</p><p>1、临界区：</p><p>通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p><p>2、互斥量 Synchronized/Lock：</p><p>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p><p>3、信号量 Semphare：</p><p>为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p><p>4、事件(信号)，Wait/Notify：</p><p>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/14/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/07/14/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="题目：存储过程与触发器的区别"><a href="#题目：存储过程与触发器的区别" class="headerlink" title="题目：存储过程与触发器的区别"></a><strong>题目</strong>：存储过程与触发器的区别</h4><h4 id="参考答案："><a href="#参考答案：" class="headerlink" title="参考答案："></a><strong>参考答案</strong>：</h4><p>触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。</p><p>触发器是在一个修改了指定表中的数据时执行的存储过程。</p><p>通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。</p><p>触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/14/%E4%B8%BB%E9%94%AE%20%E8%B6%85%E9%94%AE%20%E5%80%99%E9%80%89%E9%94%AE%20%E5%A4%96%E9%94%AE/"/>
    <url>/2021/07/14/%E4%B8%BB%E9%94%AE%20%E8%B6%85%E9%94%AE%20%E5%80%99%E9%80%89%E9%94%AE%20%E5%A4%96%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h4 id="题目：主键-超键-候选键-外键是什么"><a href="#题目：主键-超键-候选键-外键是什么" class="headerlink" title="题目：主键 超键 候选键 外键是什么"></a><strong>题目</strong>：主键 超键 候选键 外键是什么</h4><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>超键(super key)</strong>: 在关系中能唯一标识元组的属性集称为关系模式的超键.</p><p><strong>候选键(candidate key)</strong>: 不含有多余属性的超键称为候选键。也就是在候选键中，若再删除属性，就不是键了！</p><p><strong>主键(primary key)</strong>: 用户选作元组标识的一个候选键程序主键</p><p>**外键(foreign key)**：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>比如有如下数据：</p><table><thead><tr><th align="center">学号</th><th align="center">姓名</th><th align="center">性别</th><th align="center">年龄</th><th align="center">系别</th><th align="center">专业</th></tr></thead><tbody><tr><td align="center">20020612</td><td align="center">李辉</td><td align="center">男</td><td align="center">20</td><td align="center">计算机</td><td align="center">软件开发</td></tr><tr><td align="center">20060613</td><td align="center">张明</td><td align="center">男</td><td align="center">18</td><td align="center">计算机</td><td align="center">软件开发</td></tr><tr><td align="center">20060614</td><td align="center">王小玉</td><td align="center">女</td><td align="center">19</td><td align="center">物理</td><td align="center">力学</td></tr><tr><td align="center">20060615</td><td align="center">李淑华</td><td align="center">女</td><td align="center">17</td><td align="center">生物</td><td align="center">动物学</td></tr><tr><td align="center">20060616</td><td align="center">赵静</td><td align="center">男</td><td align="center">21</td><td align="center">化学</td><td align="center">食品化学</td></tr><tr><td align="center">20060617</td><td align="center">赵静</td><td align="center">女</td><td align="center">20</td><td align="center">生物</td><td align="center">植物学</td></tr></tbody></table><ol><li><p>超键</p><p> 在关系中能唯一标识元组的属性集称为关系模式的超键。</p><p> 于是我们从例子中可以发现 学号是标识学生实体的唯一标识。那么该元组的超键就为学号。</p><p> 除此之外我们还可以把它跟其他属性组合起来，比如：</p><p> (<code>学号</code>，<code>性别</code>)</p><p> (<code>学号</code>，<code>年龄</code>)</p><p> 这样也是超键.</p></li><li><p>候选键</p><p> 不含多余属性的超键为候选键。</p><p> 根据例子可知，学号是一个可以唯一标识元组的唯一标识，因此学号是一个候选键，实际上，候选键是超键的子集，比如 （学号，年龄）是超键，但是它不是候选键。因为它还有了额外的属性。</p></li><li><p>主键</p><p> 用户选择的候选键作为该元组的唯一标识，那么它就为主键。</p><p> 简单的说，例子中的元组的候选键为学号，但是我们选定他作为该元组的唯一标识，那么学号就为主键。</p></li><li><p>外键</p><p> 外键是相对于主键的，比如在学生记录里，主键为学号，在成绩单表中也有学号字段，因此学号为成绩单表的外键，为学生表的主键。</p></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>主键为候选键的子集，候选键为超键的子集，而外键的确定是相对于主键的。</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/07/14/hello-world/"/>
    <url>/2021/07/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
